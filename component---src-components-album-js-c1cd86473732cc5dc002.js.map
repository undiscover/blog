{"version":3,"sources":["webpack:///./node_modules/core-js/modules/es6.object.freeze.js","webpack:///./node_modules/remarkable/dist/esm/index.browser.js","webpack:///./src/components/album.js","webpack:///./node_modules/core-js/modules/es6.number.constructor.js"],"names":["isObject","meta","onFreeze","$freeze","it","decodeEntity","name","document","createElement","innerHTML","value","hasOwn","Object","prototype","hasOwnProperty","has","object","key","call","obj","sources","slice","arguments","forEach","source","TypeError","keys","UNESCAPE_MD_RE","unescapeMd","str","indexOf","replace","isValidEntityCode","c","fromCodePoint","surrogate1","surrogate2","String","fromCharCode","NAMED_ENTITY_RE","DIGITAL_ENTITY_TEST_RE","replaceEntityPattern","match","code","decoded","charCodeAt","test","toLowerCase","parseInt","replaceEntities","HTML_ESCAPE_TEST_RE","HTML_ESCAPE_REPLACE_RE","HTML_REPLACEMENTS","replaceUnsafeChar","ch","escapeHtml","rules","blockquote_open","blockquote_close","tokens","idx","getBreak","block","content","fence","options","env","instance","fences","fenceName","token","langClass","langPrefix","params","split","join","fence_custom","highlight","apply","concat","heading_open","hLevel","heading_close","hr","xhtmlOut","bullet_list_open","bullet_list_close","list_item_open","list_item_close","ordered_list_open","order","ordered_list_close","paragraph_open","tight","paragraph_close","addBreak","type","link_open","title","target","linkTarget","href","link_close","image","src","alt","table_open","table_close","thead_open","thead_close","tbody_open","tbody_close","tr_open","tr_close","th_open","align","th_close","td_open","td_close","strong_open","strong_close","em_open","em_close","del_open","del_close","ins_open","ins_close","mark_open","mark_close","sub","sup","hardbreak","softbreak","breaks","text","htmlblock","htmltag","abbr_open","abbr_close","footnote_ref","n","Number","id","toString","subId","footnote_block_open","footnote_block_close","footnote_open","footnote_close","footnote_anchor","dl_open","dt_open","dd_open","dl_close","dt_close","dd_close","nextToken","length","Renderer","this","Ruler","__rules__","__cache__","StateInline","parserInline","outTokens","parser","pos","posMax","level","pending","pendingLevel","cache","isInLabel","linkLevel","linkContent","labelUnmatchedScopes","parseLinkLabel","state","start","found","marker","labelEnd","max","oldPos","oldFlag","skipToken","parseAbbr","label","trim","abbreviations","normalizeLink","url","normalized","decodeURI","err","encodeURI","parseLinkDestination","link","validateLink","parseLinkTitle","normalizeReference","toUpperCase","parseReference","references","renderInline","_rules","len","i","result","render","children","__find__","__compile__","self","chains","rule","enabled","altName","push","chain","fn","at","opt","Error","before","beforeName","ruleName","splice","after","afterName","enable","list","strict","Array","isArray","disable","getRules","chainName","pushPending","cacheSet","val","cacheGet","regEscape","s","RARE_RE","SCOPED_ABBR_RE","SCOPED_ABBR","QUOTE_TEST_RE","QUOTE_RE","PUNCT_RE","isLetter","replaceAt","index","substr","inlineMode","lines","parse","l","inline","tok","j","t","lastParagraph","current","currentLabel","insideRef","refTokens","footnotes","filter","pop","count","nodes","reg","m","regText","blockTokens","abbrRegExp","map","x","sort","a","b","RegExp","lastIndex","exec","inlineTokens","blkIdx","typographer","thisLevel","lastSpace","nextSpace","item","canOpen","canClose","isSingle","stack","OUTER","single","quotes","Core","ruler","StateBlock","indent","indent_found","bMarks","eMarks","tShift","blkIndent","line","lineMax","parentType","ddIndent","skipBulletListMarker","startLine","skipOrderedListMarker","process","isEmpty","skipEmptyLines","from","skipSpaces","skipChars","skipCharsBack","min","getLines","begin","end","keepLastLF","first","last","queue","shift","Math","html_blocks","HTML_TAG_OPEN_RE","HTML_TAG_CLOSE_RE","getLine","skipMarker","_rules$1","endLine","nextLine","silent","mem","haveEndMarker","lastLineEmpty","oldTShift","oldBMarks","oldIndent","oldParentType","terminatorRules","terminate","maxNesting","tokenize","cnt","oldTight","posAfterMarker","indentAfterMarker","markerValue","markerCharCode","isOrdered","contentStart","listTokIdx","prevEmptyEnd","listLines","itemLines","markTightParagraphs","oldBMark","refs","tmp","next","html","lc","isLetter$1","lineText","rows","cell","aligns","tableLines","tbodyLines","substring","ddLine","dtLine","oldDDIndent","markTightParagraphs$1","ParserBlock","hasEmptyLines","TABS_SCAN_RE","NEWLINES_RE","SPACES_RE","isTerminatorChar","lineStart","lastTabPos","offset","ESCAPED","isAlphaNum","scanDelims","lastChar","nextChar","can_open","can_close","delims","UNESCAPE_RE","UNESCAPE_RE$1","url_schemas","EMAIL_RE","AUTOLINK_RE","replace$1","regex","attr_value","attribute","open_tag","HTML_TAG_RE","DIGITAL_RE","NAMED_RE","_rules$2","pmax","matchStart","matchEnd","startCount","oldCount","newCount","res","labelStart","ref","isImage","footnoteId","oldLength","footnoteSubId","tail","linkMatch","emailMatch","fullUrl","isLetter$2","ParserInline","cached_pos","ok","config","components","core","StateCore","renderer","Remarkable","preset","linkify","console","warn","configure","set","presets","use","plugin","parseInline","query","Album","album","data","strapiAlbum","md","author","className","style","backgroundColor","background_color","release_year","cover","publicURL","height","width","dangerouslySetInnerHTML","__html","player","description","global","cof","inheritIfRequired","toPrimitive","fails","gOPN","f","gOPD","dP","$trim","$Number","Base","proto","BROKEN_COF","TRIM","toNumber","argument","third","radix","maxCode","NaN","digits","that","valueOf","constructor"],"mappings":"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","file":"component---src-components-album-js-c1cd86473732cc5dc002.js","sourcesContent":["// 19.1.2.5 Object.freeze(O)\nvar isObject = require('./_is-object');\nvar meta = require('./_meta').onFreeze;\n\nrequire('./_object-sap')('freeze', function ($freeze) {\n  return function freeze(it) {\n    return $freeze && isObject(it) ? $freeze(meta(it)) : it;\n  };\n});\n","import \"core-js/modules/es6.regexp.match\";\nimport \"core-js/modules/es6.regexp.constructor\";\nimport \"core-js/modules/es6.array.sort\";\nimport \"core-js/modules/es6.array.map\";\nimport \"core-js/modules/es6.array.filter\";\nimport \"core-js/modules/es6.string.trim\";\nimport \"core-js/modules/es6.array.is-array\";\nimport \"core-js/modules/es6.function.name\";\nimport \"core-js/modules/es6.number.constructor\";\nimport \"core-js/modules/es6.regexp.split\";\nimport \"core-js/modules/es6.object.freeze\";\nimport \"core-js/modules/es6.regexp.replace\";\nimport \"core-js/modules/es6.array.index-of\";\nimport \"core-js/modules/web.dom.iterable\";\nimport \"core-js/modules/es6.array.iterator\";\nimport \"core-js/modules/es6.object.keys\";\nimport \"core-js/modules/es6.array.for-each\";\nimport \"core-js/modules/es6.regexp.to-string\";\nimport \"core-js/modules/es6.date.to-string\";\nimport \"core-js/modules/es6.object.to-string\";\nvar textarea;\n\nfunction decodeEntity(name) {\n  textarea = textarea || document.createElement('textarea');\n  textarea.innerHTML = '&' + name;\n  return textarea.value;\n}\n/**\n * Utility functions\n */\n\n\nfunction typeOf(obj) {\n  return Object.prototype.toString.call(obj);\n}\n\nfunction isString(obj) {\n  return typeOf(obj) === '[object String]';\n}\n\nvar hasOwn = Object.prototype.hasOwnProperty;\n\nfunction has(object, key) {\n  return object ? hasOwn.call(object, key) : false;\n} // Extend objects\n//\n\n\nfunction assign(obj\n/*from1, from2, from3, ...*/\n) {\n  var sources = [].slice.call(arguments, 1);\n  sources.forEach(function (source) {\n    if (!source) {\n      return;\n    }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be object');\n    }\n\n    Object.keys(source).forEach(function (key) {\n      obj[key] = source[key];\n    });\n  });\n  return obj;\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nvar UNESCAPE_MD_RE = /\\\\([\\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction unescapeMd(str) {\n  if (str.indexOf('\\\\') < 0) {\n    return str;\n  }\n\n  return str.replace(UNESCAPE_MD_RE, '$1');\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nfunction isValidEntityCode(c) {\n  /*eslint no-bitwise:0*/\n  // broken sequence\n  if (c >= 0xD800 && c <= 0xDFFF) {\n    return false;\n  } // never used\n\n\n  if (c >= 0xFDD0 && c <= 0xFDEF) {\n    return false;\n  }\n\n  if ((c & 0xFFFF) === 0xFFFF || (c & 0xFFFF) === 0xFFFE) {\n    return false;\n  } // control codes\n\n\n  if (c >= 0x00 && c <= 0x08) {\n    return false;\n  }\n\n  if (c === 0x0B) {\n    return false;\n  }\n\n  if (c >= 0x0E && c <= 0x1F) {\n    return false;\n  }\n\n  if (c >= 0x7F && c <= 0x9F) {\n    return false;\n  } // out of range\n\n\n  if (c > 0x10FFFF) {\n    return false;\n  }\n\n  return true;\n}\n\nfunction fromCodePoint(c) {\n  /*eslint no-bitwise:0*/\n  if (c > 0xffff) {\n    c -= 0x10000;\n    var surrogate1 = 0xd800 + (c >> 10),\n        surrogate2 = 0xdc00 + (c & 0x3ff);\n    return String.fromCharCode(surrogate1, surrogate2);\n  }\n\n  return String.fromCharCode(c);\n}\n\nvar NAMED_ENTITY_RE = /&([a-z#][a-z0-9]{1,31});/gi;\nvar DIGITAL_ENTITY_TEST_RE = /^#((?:x[a-f0-9]{1,8}|[0-9]{1,8}))/i;\n\nfunction replaceEntityPattern(match, name) {\n  var code = 0;\n  var decoded = decodeEntity(name);\n\n  if (name !== decoded) {\n    return decoded;\n  } else if (name.charCodeAt(0) === 0x23\n  /* # */\n  && DIGITAL_ENTITY_TEST_RE.test(name)) {\n    code = name[1].toLowerCase() === 'x' ? parseInt(name.slice(2), 16) : parseInt(name.slice(1), 10);\n\n    if (isValidEntityCode(code)) {\n      return fromCodePoint(code);\n    }\n  }\n\n  return match;\n}\n\nfunction replaceEntities(str) {\n  if (str.indexOf('&') < 0) {\n    return str;\n  }\n\n  return str.replace(NAMED_ENTITY_RE, replaceEntityPattern);\n} ////////////////////////////////////////////////////////////////////////////////\n\n\nvar HTML_ESCAPE_TEST_RE = /[&<>\"]/;\nvar HTML_ESCAPE_REPLACE_RE = /[&<>\"]/g;\nvar HTML_REPLACEMENTS = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;'\n};\n\nfunction replaceUnsafeChar(ch) {\n  return HTML_REPLACEMENTS[ch];\n}\n\nfunction escapeHtml(str) {\n  if (HTML_ESCAPE_TEST_RE.test(str)) {\n    return str.replace(HTML_ESCAPE_REPLACE_RE, replaceUnsafeChar);\n  }\n\n  return str;\n}\n\nvar utils = /*#__PURE__*/Object.freeze({\n  isString: isString,\n  has: has,\n  assign: assign,\n  unescapeMd: unescapeMd,\n  isValidEntityCode: isValidEntityCode,\n  fromCodePoint: fromCodePoint,\n  replaceEntities: replaceEntities,\n  escapeHtml: escapeHtml\n});\n/**\n * Renderer rules cache\n */\n\nvar rules = {};\n/**\n * Blockquotes\n */\n\nrules.blockquote_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<blockquote>\\n';\n};\n\nrules.blockquote_close = function (tokens, idx\n/*, options, env */\n) {\n  return '</blockquote>' + getBreak(tokens, idx);\n};\n/**\n * Code\n */\n\n\nrules.code = function (tokens, idx\n/*, options, env */\n) {\n  if (tokens[idx].block) {\n    return '<pre><code>' + escapeHtml(tokens[idx].content) + '</code></pre>' + getBreak(tokens, idx);\n  }\n\n  return '<code>' + escapeHtml(tokens[idx].content) + '</code>';\n};\n/**\n * Fenced code blocks\n */\n\n\nrules.fence = function (tokens, idx, options, env, instance) {\n  var token = tokens[idx];\n  var langClass = '';\n  var langPrefix = options.langPrefix;\n  var langName = '',\n      fences,\n      fenceName;\n  var highlighted;\n\n  if (token.params) {\n    //\n    // ```foo bar\n    //\n    // Try custom renderer \"foo\" first. That will simplify overwrite\n    // for diagrams, latex, and any other fenced block with custom look\n    //\n    fences = token.params.split(/\\s+/g);\n    fenceName = fences.join(' ');\n\n    if (has(instance.rules.fence_custom, fences[0])) {\n      return instance.rules.fence_custom[fences[0]](tokens, idx, options, env, instance);\n    }\n\n    langName = escapeHtml(replaceEntities(unescapeMd(fenceName)));\n    langClass = ' class=\"' + langPrefix + langName + '\"';\n  }\n\n  if (options.highlight) {\n    highlighted = options.highlight.apply(options.highlight, [token.content].concat(fences)) || escapeHtml(token.content);\n  } else {\n    highlighted = escapeHtml(token.content);\n  }\n\n  return '<pre><code' + langClass + '>' + highlighted + '</code></pre>' + getBreak(tokens, idx);\n};\n\nrules.fence_custom = {};\n/**\n * Headings\n */\n\nrules.heading_open = function (tokens, idx\n/*, options, env */\n) {\n  return '<h' + tokens[idx].hLevel + '>';\n};\n\nrules.heading_close = function (tokens, idx\n/*, options, env */\n) {\n  return '</h' + tokens[idx].hLevel + '>\\n';\n};\n/**\n * Horizontal rules\n */\n\n\nrules.hr = function (tokens, idx, options\n/*, env */\n) {\n  return (options.xhtmlOut ? '<hr />' : '<hr>') + getBreak(tokens, idx);\n};\n/**\n * Bullets\n */\n\n\nrules.bullet_list_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<ul>\\n';\n};\n\nrules.bullet_list_close = function (tokens, idx\n/*, options, env */\n) {\n  return '</ul>' + getBreak(tokens, idx);\n};\n/**\n * List items\n */\n\n\nrules.list_item_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<li>';\n};\n\nrules.list_item_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</li>\\n';\n};\n/**\n * Ordered list items\n */\n\n\nrules.ordered_list_open = function (tokens, idx\n/*, options, env */\n) {\n  var token = tokens[idx];\n  var order = token.order > 1 ? ' start=\"' + token.order + '\"' : '';\n  return '<ol' + order + '>\\n';\n};\n\nrules.ordered_list_close = function (tokens, idx\n/*, options, env */\n) {\n  return '</ol>' + getBreak(tokens, idx);\n};\n/**\n * Paragraphs\n */\n\n\nrules.paragraph_open = function (tokens, idx\n/*, options, env */\n) {\n  return tokens[idx].tight ? '' : '<p>';\n};\n\nrules.paragraph_close = function (tokens, idx\n/*, options, env */\n) {\n  var addBreak = !(tokens[idx].tight && idx && tokens[idx - 1].type === 'inline' && !tokens[idx - 1].content);\n  return (tokens[idx].tight ? '' : '</p>') + (addBreak ? getBreak(tokens, idx) : '');\n};\n/**\n * Links\n */\n\n\nrules.link_open = function (tokens, idx, options\n/* env */\n) {\n  var title = tokens[idx].title ? ' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"' : '';\n  var target = options.linkTarget ? ' target=\"' + options.linkTarget + '\"' : '';\n  return '<a href=\"' + escapeHtml(tokens[idx].href) + '\"' + title + target + '>';\n};\n\nrules.link_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</a>';\n};\n/**\n * Images\n */\n\n\nrules.image = function (tokens, idx, options\n/*, env */\n) {\n  var src = ' src=\"' + escapeHtml(tokens[idx].src) + '\"';\n  var title = tokens[idx].title ? ' title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\"' : '';\n  var alt = ' alt=\"' + (tokens[idx].alt ? escapeHtml(replaceEntities(unescapeMd(tokens[idx].alt))) : '') + '\"';\n  var suffix = options.xhtmlOut ? ' /' : '';\n  return '<img' + src + alt + title + suffix + '>';\n};\n/**\n * Tables\n */\n\n\nrules.table_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<table>\\n';\n};\n\nrules.table_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</table>\\n';\n};\n\nrules.thead_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<thead>\\n';\n};\n\nrules.thead_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</thead>\\n';\n};\n\nrules.tbody_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<tbody>\\n';\n};\n\nrules.tbody_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</tbody>\\n';\n};\n\nrules.tr_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<tr>';\n};\n\nrules.tr_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</tr>\\n';\n};\n\nrules.th_open = function (tokens, idx\n/*, options, env */\n) {\n  var token = tokens[idx];\n  return '<th' + (token.align ? ' style=\"text-align:' + token.align + '\"' : '') + '>';\n};\n\nrules.th_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</th>';\n};\n\nrules.td_open = function (tokens, idx\n/*, options, env */\n) {\n  var token = tokens[idx];\n  return '<td' + (token.align ? ' style=\"text-align:' + token.align + '\"' : '') + '>';\n};\n\nrules.td_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</td>';\n};\n/**\n * Bold\n */\n\n\nrules.strong_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<strong>';\n};\n\nrules.strong_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</strong>';\n};\n/**\n * Italicize\n */\n\n\nrules.em_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<em>';\n};\n\nrules.em_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</em>';\n};\n/**\n * Strikethrough\n */\n\n\nrules.del_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<del>';\n};\n\nrules.del_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</del>';\n};\n/**\n * Insert\n */\n\n\nrules.ins_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<ins>';\n};\n\nrules.ins_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</ins>';\n};\n/**\n * Highlight\n */\n\n\nrules.mark_open = function ()\n/* tokens, idx, options, env */\n{\n  return '<mark>';\n};\n\nrules.mark_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</mark>';\n};\n/**\n * Super- and sub-script\n */\n\n\nrules.sub = function (tokens, idx\n/*, options, env */\n) {\n  return '<sub>' + escapeHtml(tokens[idx].content) + '</sub>';\n};\n\nrules.sup = function (tokens, idx\n/*, options, env */\n) {\n  return '<sup>' + escapeHtml(tokens[idx].content) + '</sup>';\n};\n/**\n * Breaks\n */\n\n\nrules.hardbreak = function (tokens, idx, options\n/*, env */\n) {\n  return options.xhtmlOut ? '<br />\\n' : '<br>\\n';\n};\n\nrules.softbreak = function (tokens, idx, options\n/*, env */\n) {\n  return options.breaks ? options.xhtmlOut ? '<br />\\n' : '<br>\\n' : '\\n';\n};\n/**\n * Text\n */\n\n\nrules.text = function (tokens, idx\n/*, options, env */\n) {\n  return escapeHtml(tokens[idx].content);\n};\n/**\n * Content\n */\n\n\nrules.htmlblock = function (tokens, idx\n/*, options, env */\n) {\n  return tokens[idx].content;\n};\n\nrules.htmltag = function (tokens, idx\n/*, options, env */\n) {\n  return tokens[idx].content;\n};\n/**\n * Abbreviations, initialism\n */\n\n\nrules.abbr_open = function (tokens, idx\n/*, options, env */\n) {\n  return '<abbr title=\"' + escapeHtml(replaceEntities(tokens[idx].title)) + '\">';\n};\n\nrules.abbr_close = function ()\n/* tokens, idx, options, env */\n{\n  return '</abbr>';\n};\n/**\n * Footnotes\n */\n\n\nrules.footnote_ref = function (tokens, idx) {\n  var n = Number(tokens[idx].id + 1).toString();\n  var id = 'fnref' + n;\n\n  if (tokens[idx].subId > 0) {\n    id += ':' + tokens[idx].subId;\n  }\n\n  return '<sup class=\"footnote-ref\"><a href=\"#fn' + n + '\" id=\"' + id + '\">[' + n + ']</a></sup>';\n};\n\nrules.footnote_block_open = function (tokens, idx, options) {\n  var hr = options.xhtmlOut ? '<hr class=\"footnotes-sep\" />\\n' : '<hr class=\"footnotes-sep\">\\n';\n  return hr + '<section class=\"footnotes\">\\n<ol class=\"footnotes-list\">\\n';\n};\n\nrules.footnote_block_close = function () {\n  return '</ol>\\n</section>\\n';\n};\n\nrules.footnote_open = function (tokens, idx) {\n  var id = Number(tokens[idx].id + 1).toString();\n  return '<li id=\"fn' + id + '\"  class=\"footnote-item\">';\n};\n\nrules.footnote_close = function () {\n  return '</li>\\n';\n};\n\nrules.footnote_anchor = function (tokens, idx) {\n  var n = Number(tokens[idx].id + 1).toString();\n  var id = 'fnref' + n;\n\n  if (tokens[idx].subId > 0) {\n    id += ':' + tokens[idx].subId;\n  }\n\n  return ' <a href=\"#' + id + '\" class=\"footnote-backref\">↩</a>';\n};\n/**\n * Definition lists\n */\n\n\nrules.dl_open = function () {\n  return '<dl>\\n';\n};\n\nrules.dt_open = function () {\n  return '<dt>';\n};\n\nrules.dd_open = function () {\n  return '<dd>';\n};\n\nrules.dl_close = function () {\n  return '</dl>\\n';\n};\n\nrules.dt_close = function () {\n  return '</dt>\\n';\n};\n\nrules.dd_close = function () {\n  return '</dd>\\n';\n};\n/**\n * Helper functions\n */\n\n\nfunction nextToken(tokens, idx) {\n  if (++idx >= tokens.length - 2) {\n    return idx;\n  }\n\n  if (tokens[idx].type === 'paragraph_open' && tokens[idx].tight && tokens[idx + 1].type === 'inline' && tokens[idx + 1].content.length === 0 && tokens[idx + 2].type === 'paragraph_close' && tokens[idx + 2].tight) {\n    return nextToken(tokens, idx + 2);\n  }\n\n  return idx;\n}\n/**\n * Check to see if `\\n` is needed before the next token.\n *\n * @param  {Array} `tokens`\n * @param  {Number} `idx`\n * @return {String} Empty string or newline\n * @api private\n */\n\n\nvar getBreak = rules.getBreak = function getBreak(tokens, idx) {\n  idx = nextToken(tokens, idx);\n\n  if (idx < tokens.length && tokens[idx].type === 'list_item_close') {\n    return '';\n  }\n\n  return '\\n';\n};\n/**\n * Renderer class. Renders HTML and exposes `rules` to allow\n * local modifications.\n */\n\n\nfunction Renderer() {\n  this.rules = assign({}, rules); // exported helper, for custom rules only\n\n  this.getBreak = rules.getBreak;\n}\n/**\n * Render a string of inline HTML with the given `tokens` and\n * `options`.\n *\n * @param  {Array} `tokens`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @return {String}\n * @api public\n */\n\n\nRenderer.prototype.renderInline = function (tokens, options, env) {\n  var _rules = this.rules;\n  var len = tokens.length,\n      i = 0;\n  var result = '';\n\n  while (len--) {\n    result += _rules[tokens[i].type](tokens, i++, options, env, this);\n  }\n\n  return result;\n};\n/**\n * Render a string of HTML with the given `tokens` and\n * `options`.\n *\n * @param  {Array} `tokens`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @return {String}\n * @api public\n */\n\n\nRenderer.prototype.render = function (tokens, options, env) {\n  var _rules = this.rules;\n  var len = tokens.length,\n      i = -1;\n  var result = '';\n\n  while (++i < len) {\n    if (tokens[i].type === 'inline') {\n      result += this.renderInline(tokens[i].children, options, env);\n    } else {\n      result += _rules[tokens[i].type](tokens, i, options, env, this);\n    }\n  }\n\n  return result;\n};\n/**\n * Ruler is a helper class for building responsibility chains from\n * parse rules. It allows:\n *\n *   - easy stack rules chains\n *   - getting main chain and named chains content (as arrays of functions)\n *\n * Helper methods, should not be used directly.\n * @api private\n */\n\n\nfunction Ruler() {\n  // List of added rules. Each element is:\n  //\n  // { name: XXX,\n  //   enabled: Boolean,\n  //   fn: Function(),\n  //   alt: [ name2, name3 ] }\n  //\n  this.__rules__ = []; // Cached rule chains.\n  //\n  // First level - chain name, '' for default.\n  // Second level - digital anchor for fast filtering by charcodes.\n  //\n\n  this.__cache__ = null;\n}\n/**\n * Find the index of a rule by `name`.\n *\n * @param  {String} `name`\n * @return {Number} Index of the given `name`\n * @api private\n */\n\n\nRuler.prototype.__find__ = function (name) {\n  var len = this.__rules__.length;\n  var i = -1;\n\n  while (len--) {\n    if (this.__rules__[++i].name === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Build the rules lookup cache\n *\n * @api private\n */\n\n\nRuler.prototype.__compile__ = function () {\n  var self = this;\n  var chains = ['']; // collect unique names\n\n  self.__rules__.forEach(function (rule) {\n    if (!rule.enabled) {\n      return;\n    }\n\n    rule.alt.forEach(function (altName) {\n      if (chains.indexOf(altName) < 0) {\n        chains.push(altName);\n      }\n    });\n  });\n\n  self.__cache__ = {};\n  chains.forEach(function (chain) {\n    self.__cache__[chain] = [];\n\n    self.__rules__.forEach(function (rule) {\n      if (!rule.enabled) {\n        return;\n      }\n\n      if (chain && rule.alt.indexOf(chain) < 0) {\n        return;\n      }\n\n      self.__cache__[chain].push(rule.fn);\n    });\n  });\n};\n/**\n * Ruler public methods\n * ------------------------------------------------\n */\n\n/**\n * Replace rule function\n *\n * @param  {String} `name` Rule name\n * @param  {Function `fn`\n * @param  {Object} `options`\n * @api private\n */\n\n\nRuler.prototype.at = function (name, fn, options) {\n  var idx = this.__find__(name);\n\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + name);\n  }\n\n  this.__rules__[idx].fn = fn;\n  this.__rules__[idx].alt = opt.alt || [];\n  this.__cache__ = null;\n};\n/**\n * Add a rule to the chain before given the `ruleName`.\n *\n * @param  {String}   `beforeName`\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @api private\n */\n\n\nRuler.prototype.before = function (beforeName, ruleName, fn, options) {\n  var idx = this.__find__(beforeName);\n\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + beforeName);\n  }\n\n  this.__rules__.splice(idx, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n/**\n * Add a rule to the chain after the given `ruleName`.\n *\n * @param  {String}   `afterName`\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @api private\n */\n\n\nRuler.prototype.after = function (afterName, ruleName, fn, options) {\n  var idx = this.__find__(afterName);\n\n  var opt = options || {};\n\n  if (idx === -1) {\n    throw new Error('Parser rule not found: ' + afterName);\n  }\n\n  this.__rules__.splice(idx + 1, 0, {\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n/**\n * Add a rule to the end of chain.\n *\n * @param  {String}   `ruleName`\n * @param  {Function} `fn`\n * @param  {Object}   `options`\n * @return {String}\n */\n\n\nRuler.prototype.push = function (ruleName, fn, options) {\n  var opt = options || {};\n\n  this.__rules__.push({\n    name: ruleName,\n    enabled: true,\n    fn: fn,\n    alt: opt.alt || []\n  });\n\n  this.__cache__ = null;\n};\n/**\n * Enable a rule or list of rules.\n *\n * @param  {String|Array} `list` Name or array of rule names to enable\n * @param  {Boolean} `strict` If `true`, all non listed rules will be disabled.\n * @api private\n */\n\n\nRuler.prototype.enable = function (list, strict) {\n  list = !Array.isArray(list) ? [list] : list; // In strict mode disable all existing rules first\n\n  if (strict) {\n    this.__rules__.forEach(function (rule) {\n      rule.enabled = false;\n    });\n  } // Search by name and enable\n\n\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n\n    this.__rules__[idx].enabled = true;\n  }, this);\n  this.__cache__ = null;\n};\n/**\n * Disable a rule or list of rules.\n *\n * @param  {String|Array} `list` Name or array of rule names to disable\n * @api private\n */\n\n\nRuler.prototype.disable = function (list) {\n  list = !Array.isArray(list) ? [list] : list; // Search by name and disable\n\n  list.forEach(function (name) {\n    var idx = this.__find__(name);\n\n    if (idx < 0) {\n      throw new Error('Rules manager: invalid rule name ' + name);\n    }\n\n    this.__rules__[idx].enabled = false;\n  }, this);\n  this.__cache__ = null;\n};\n/**\n * Get a rules list as an array of functions.\n *\n * @param  {String} `chainName`\n * @return {Object}\n * @api private\n */\n\n\nRuler.prototype.getRules = function (chainName) {\n  if (this.__cache__ === null) {\n    this.__compile__();\n  }\n\n  return this.__cache__[chainName] || [];\n};\n\nfunction block(state) {\n  if (state.inlineMode) {\n    state.tokens.push({\n      type: 'inline',\n      content: state.src.replace(/\\n/g, ' ').trim(),\n      level: 0,\n      lines: [0, 1],\n      children: []\n    });\n  } else {\n    state.block.parse(state.src, state.options, state.env, state.tokens);\n  }\n} // Inline parser state\n\n\nfunction StateInline(src, parserInline, options, env, outTokens) {\n  this.src = src;\n  this.env = env;\n  this.options = options;\n  this.parser = parserInline;\n  this.tokens = outTokens;\n  this.pos = 0;\n  this.posMax = this.src.length;\n  this.level = 0;\n  this.pending = '';\n  this.pendingLevel = 0;\n  this.cache = []; // Stores { start: end } pairs. Useful for backtrack\n  // optimization of pairs parse (emphasis, strikes).\n  // Link parser state vars\n\n  this.isInLabel = false; // Set true when seek link label - we should disable\n  // \"paired\" rules (emphasis, strikes) to not skip\n  // tailing `]`\n\n  this.linkLevel = 0; // Increment for each nesting link. Used to prevent\n  // nesting in definitions\n\n  this.linkContent = ''; // Temporary storage for link url\n\n  this.labelUnmatchedScopes = 0; // Track unpaired `[` for link labels\n  // (backtrack optimization)\n} // Flush pending text\n//\n\n\nStateInline.prototype.pushPending = function () {\n  this.tokens.push({\n    type: 'text',\n    content: this.pending,\n    level: this.pendingLevel\n  });\n  this.pending = '';\n}; // Push new token to \"stream\".\n// If pending text exists - flush it as text token\n//\n\n\nStateInline.prototype.push = function (token) {\n  if (this.pending) {\n    this.pushPending();\n  }\n\n  this.tokens.push(token);\n  this.pendingLevel = this.level;\n}; // Store value to cache.\n// !!! Implementation has parser-specific optimizations\n// !!! keys MUST be integer, >= 0; values MUST be integer, > 0\n//\n\n\nStateInline.prototype.cacheSet = function (key, val) {\n  for (var i = this.cache.length; i <= key; i++) {\n    this.cache.push(0);\n  }\n\n  this.cache[key] = val;\n}; // Get cache value\n//\n\n\nStateInline.prototype.cacheGet = function (key) {\n  return key < this.cache.length ? this.cache[key] : 0;\n};\n/**\n * Parse link labels\n *\n * This function assumes that first character (`[`) already matches;\n * returns the end of the label.\n *\n * @param  {Object} state\n * @param  {Number} start\n * @api private\n */\n\n\nfunction parseLinkLabel(state, start) {\n  var level,\n      found,\n      marker,\n      labelEnd = -1,\n      max = state.posMax,\n      oldPos = state.pos,\n      oldFlag = state.isInLabel;\n\n  if (state.isInLabel) {\n    return -1;\n  }\n\n  if (state.labelUnmatchedScopes) {\n    state.labelUnmatchedScopes--;\n    return -1;\n  }\n\n  state.pos = start + 1;\n  state.isInLabel = true;\n  level = 1;\n\n  while (state.pos < max) {\n    marker = state.src.charCodeAt(state.pos);\n\n    if (marker === 0x5B\n    /* [ */\n    ) {\n        level++;\n      } else if (marker === 0x5D\n    /* ] */\n    ) {\n        level--;\n\n        if (level === 0) {\n          found = true;\n          break;\n        }\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (found) {\n    labelEnd = state.pos;\n    state.labelUnmatchedScopes = 0;\n  } else {\n    state.labelUnmatchedScopes = level - 1;\n  } // restore old state\n\n\n  state.pos = oldPos;\n  state.isInLabel = oldFlag;\n  return labelEnd;\n} // Parse abbreviation definitions, i.e. `*[abbr]: description`\n\n\nfunction parseAbbr(str, parserInline, options, env) {\n  var state, labelEnd, pos, max, label, title;\n\n  if (str.charCodeAt(0) !== 0x2A\n  /* * */\n  ) {\n      return -1;\n    }\n\n  if (str.charCodeAt(1) !== 0x5B\n  /* [ */\n  ) {\n      return -1;\n    }\n\n  if (str.indexOf(']:') === -1) {\n    return -1;\n  }\n\n  state = new StateInline(str, parserInline, options, env, []);\n  labelEnd = parseLinkLabel(state, 1);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A\n  /* : */\n  ) {\n      return -1;\n    }\n\n  max = state.posMax; // abbr title is always one line, so looking for ending \"\\n\" here\n\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x0A) {\n      break;\n    }\n  }\n\n  label = str.slice(2, labelEnd);\n  title = str.slice(labelEnd + 2, pos).trim();\n\n  if (title.length === 0) {\n    return -1;\n  }\n\n  if (!env.abbreviations) {\n    env.abbreviations = {};\n  } // prepend ':' to avoid conflict with Object.prototype members\n\n\n  if (typeof env.abbreviations[':' + label] === 'undefined') {\n    env.abbreviations[':' + label] = title;\n  }\n\n  return pos;\n}\n\nfunction abbr(state) {\n  var tokens = state.tokens,\n      i,\n      l,\n      content,\n      pos;\n\n  if (state.inlineMode) {\n    return;\n  } // Parse inlines\n\n\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i - 1].type === 'paragraph_open' && tokens[i].type === 'inline' && tokens[i + 1].type === 'paragraph_close') {\n      content = tokens[i].content;\n\n      while (content.length) {\n        pos = parseAbbr(content, state.inline, state.options, state.env);\n\n        if (pos < 0) {\n          break;\n        }\n\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n}\n\nfunction normalizeLink(url) {\n  var normalized = replaceEntities(url); // We shouldn't care about the result of malformed URIs,\n  // and should not throw an exception.\n\n  try {\n    normalized = decodeURI(normalized);\n  } catch (err) {}\n\n  return encodeURI(normalized);\n}\n/**\n * Parse link destination\n *\n *   - on success it returns a string and updates state.pos;\n *   - on failure it returns null\n *\n * @param  {Object} state\n * @param  {Number} pos\n * @api private\n */\n\n\nfunction parseLinkDestination(state, pos) {\n  var code,\n      level,\n      link,\n      start = pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(pos) === 0x3C\n  /* < */\n  ) {\n      pos++;\n\n      while (pos < max) {\n        code = state.src.charCodeAt(pos);\n\n        if (code === 0x0A\n        /* \\n */\n        ) {\n            return false;\n          }\n\n        if (code === 0x3E\n        /* > */\n        ) {\n            link = normalizeLink(unescapeMd(state.src.slice(start + 1, pos)));\n\n            if (!state.parser.validateLink(link)) {\n              return false;\n            }\n\n            state.pos = pos + 1;\n            state.linkContent = link;\n            return true;\n          }\n\n        if (code === 0x5C\n        /* \\ */\n        && pos + 1 < max) {\n          pos += 2;\n          continue;\n        }\n\n        pos++;\n      } // no closing '>'\n\n\n      return false;\n    } // this should be ... } else { ... branch\n\n\n  level = 0;\n\n  while (pos < max) {\n    code = state.src.charCodeAt(pos);\n\n    if (code === 0x20) {\n      break;\n    } // ascii control chars\n\n\n    if (code < 0x20 || code === 0x7F) {\n      break;\n    }\n\n    if (code === 0x5C\n    /* \\ */\n    && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    if (code === 0x28\n    /* ( */\n    ) {\n        level++;\n\n        if (level > 1) {\n          break;\n        }\n      }\n\n    if (code === 0x29\n    /* ) */\n    ) {\n        level--;\n\n        if (level < 0) {\n          break;\n        }\n      }\n\n    pos++;\n  }\n\n  if (start === pos) {\n    return false;\n  }\n\n  link = unescapeMd(state.src.slice(start, pos));\n\n  if (!state.parser.validateLink(link)) {\n    return false;\n  }\n\n  state.linkContent = link;\n  state.pos = pos;\n  return true;\n}\n/**\n * Parse link title\n *\n *   - on success it returns a string and updates state.pos;\n *   - on failure it returns null\n *\n * @param  {Object} state\n * @param  {Number} pos\n * @api private\n */\n\n\nfunction parseLinkTitle(state, pos) {\n  var code,\n      start = pos,\n      max = state.posMax,\n      marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x22\n  /* \" */\n  && marker !== 0x27\n  /* ' */\n  && marker !== 0x28\n  /* ( */\n  ) {\n      return false;\n    }\n\n  pos++; // if opening marker is \"(\", switch it to closing marker \")\"\n\n  if (marker === 0x28) {\n    marker = 0x29;\n  }\n\n  while (pos < max) {\n    code = state.src.charCodeAt(pos);\n\n    if (code === marker) {\n      state.pos = pos + 1;\n      state.linkContent = unescapeMd(state.src.slice(start + 1, pos));\n      return true;\n    }\n\n    if (code === 0x5C\n    /* \\ */\n    && pos + 1 < max) {\n      pos += 2;\n      continue;\n    }\n\n    pos++;\n  }\n\n  return false;\n}\n\nfunction normalizeReference(str) {\n  // use .toUpperCase() instead of .toLowerCase()\n  // here to avoid a conflict with Object.prototype\n  // members (most notably, `__proto__`)\n  return str.trim().replace(/\\s+/g, ' ').toUpperCase();\n}\n\nfunction parseReference(str, parser, options, env) {\n  var state, labelEnd, pos, max, code, start, href, title, label;\n\n  if (str.charCodeAt(0) !== 0x5B\n  /* [ */\n  ) {\n      return -1;\n    }\n\n  if (str.indexOf(']:') === -1) {\n    return -1;\n  }\n\n  state = new StateInline(str, parser, options, env, []);\n  labelEnd = parseLinkLabel(state, 0);\n\n  if (labelEnd < 0 || str.charCodeAt(labelEnd + 1) !== 0x3A\n  /* : */\n  ) {\n      return -1;\n    }\n\n  max = state.posMax; // [label]:   destination   'title'\n  //         ^^^ skip optional whitespace here\n\n  for (pos = labelEnd + 2; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n\n    if (code !== 0x20 && code !== 0x0A) {\n      break;\n    }\n  } // [label]:   destination   'title'\n  //            ^^^^^^^^^^^ parse this\n\n\n  if (!parseLinkDestination(state, pos)) {\n    return -1;\n  }\n\n  href = state.linkContent;\n  pos = state.pos; // [label]:   destination   'title'\n  //                       ^^^ skipping those spaces\n\n  start = pos;\n\n  for (pos = pos + 1; pos < max; pos++) {\n    code = state.src.charCodeAt(pos);\n\n    if (code !== 0x20 && code !== 0x0A) {\n      break;\n    }\n  } // [label]:   destination   'title'\n  //                          ^^^^^^^ parse this\n\n\n  if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n    title = state.linkContent;\n    pos = state.pos;\n  } else {\n    title = '';\n    pos = start;\n  } // ensure that the end of the line is empty\n\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x20\n  /* space */\n  ) {\n    pos++;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x0A) {\n    return -1;\n  }\n\n  label = normalizeReference(str.slice(1, labelEnd));\n\n  if (typeof env.references[label] === 'undefined') {\n    env.references[label] = {\n      title: title,\n      href: href\n    };\n  }\n\n  return pos;\n}\n\nfunction references(state) {\n  var tokens = state.tokens,\n      i,\n      l,\n      content,\n      pos;\n  state.env.references = state.env.references || {};\n\n  if (state.inlineMode) {\n    return;\n  } // Scan definitions in paragraph inlines\n\n\n  for (i = 1, l = tokens.length - 1; i < l; i++) {\n    if (tokens[i].type === 'inline' && tokens[i - 1].type === 'paragraph_open' && tokens[i + 1].type === 'paragraph_close') {\n      content = tokens[i].content;\n\n      while (content.length) {\n        pos = parseReference(content, state.inline, state.options, state.env);\n\n        if (pos < 0) {\n          break;\n        }\n\n        content = content.slice(pos).trim();\n      }\n\n      tokens[i].content = content;\n\n      if (!content.length) {\n        tokens[i - 1].tight = true;\n        tokens[i + 1].tight = true;\n      }\n    }\n  }\n}\n\nfunction inline(state) {\n  var tokens = state.tokens,\n      tok,\n      i,\n      l; // Parse inlines\n\n  for (i = 0, l = tokens.length; i < l; i++) {\n    tok = tokens[i];\n\n    if (tok.type === 'inline') {\n      state.inline.parse(tok.content, state.options, state.env, tok.children);\n    }\n  }\n}\n\nfunction footnote_block(state) {\n  var i,\n      l,\n      j,\n      t,\n      lastParagraph,\n      list,\n      tokens,\n      current,\n      currentLabel,\n      level = 0,\n      insideRef = false,\n      refTokens = {};\n\n  if (!state.env.footnotes) {\n    return;\n  }\n\n  state.tokens = state.tokens.filter(function (tok) {\n    if (tok.type === 'footnote_reference_open') {\n      insideRef = true;\n      current = [];\n      currentLabel = tok.label;\n      return false;\n    }\n\n    if (tok.type === 'footnote_reference_close') {\n      insideRef = false; // prepend ':' to avoid conflict with Object.prototype members\n\n      refTokens[':' + currentLabel] = current;\n      return false;\n    }\n\n    if (insideRef) {\n      current.push(tok);\n    }\n\n    return !insideRef;\n  });\n\n  if (!state.env.footnotes.list) {\n    return;\n  }\n\n  list = state.env.footnotes.list;\n  state.tokens.push({\n    type: 'footnote_block_open',\n    level: level++\n  });\n\n  for (i = 0, l = list.length; i < l; i++) {\n    state.tokens.push({\n      type: 'footnote_open',\n      id: i,\n      level: level++\n    });\n\n    if (list[i].tokens) {\n      tokens = [];\n      tokens.push({\n        type: 'paragraph_open',\n        tight: false,\n        level: level++\n      });\n      tokens.push({\n        type: 'inline',\n        content: '',\n        level: level,\n        children: list[i].tokens\n      });\n      tokens.push({\n        type: 'paragraph_close',\n        tight: false,\n        level: --level\n      });\n    } else if (list[i].label) {\n      tokens = refTokens[':' + list[i].label];\n    }\n\n    state.tokens = state.tokens.concat(tokens);\n\n    if (state.tokens[state.tokens.length - 1].type === 'paragraph_close') {\n      lastParagraph = state.tokens.pop();\n    } else {\n      lastParagraph = null;\n    }\n\n    t = list[i].count > 0 ? list[i].count : 1;\n\n    for (j = 0; j < t; j++) {\n      state.tokens.push({\n        type: 'footnote_anchor',\n        id: i,\n        subId: j,\n        level: level\n      });\n    }\n\n    if (lastParagraph) {\n      state.tokens.push(lastParagraph);\n    }\n\n    state.tokens.push({\n      type: 'footnote_close',\n      level: --level\n    });\n  }\n\n  state.tokens.push({\n    type: 'footnote_block_close',\n    level: --level\n  });\n} // Enclose abbreviations in <abbr> tags\n//\n\n\nvar PUNCT_CHARS = ' \\n()[]\\'\".,!?-'; // from Google closure library\n// http://closure-library.googlecode.com/git-history/docs/local_closure_goog_string_string.js.source.html#line1021\n\nfunction regEscape(s) {\n  return s.replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1');\n}\n\nfunction abbr2(state) {\n  var i,\n      j,\n      l,\n      tokens,\n      token,\n      text,\n      nodes,\n      pos,\n      level,\n      reg,\n      m,\n      regText,\n      blockTokens = state.tokens;\n\n  if (!state.env.abbreviations) {\n    return;\n  }\n\n  if (!state.env.abbrRegExp) {\n    regText = '(^|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])' + '(' + Object.keys(state.env.abbreviations).map(function (x) {\n      return x.substr(1);\n    }).sort(function (a, b) {\n      return b.length - a.length;\n    }).map(regEscape).join('|') + ')' + '($|[' + PUNCT_CHARS.split('').map(regEscape).join('') + '])';\n    state.env.abbrRegExp = new RegExp(regText, 'g');\n  }\n\n  reg = state.env.abbrRegExp;\n\n  for (j = 0, l = blockTokens.length; j < l; j++) {\n    if (blockTokens[j].type !== 'inline') {\n      continue;\n    }\n\n    tokens = blockTokens[j].children; // We scan from the end, to keep position when new tags added.\n\n    for (i = tokens.length - 1; i >= 0; i--) {\n      token = tokens[i];\n\n      if (token.type !== 'text') {\n        continue;\n      }\n\n      pos = 0;\n      text = token.content;\n      reg.lastIndex = 0;\n      level = token.level;\n      nodes = [];\n\n      while (m = reg.exec(text)) {\n        if (reg.lastIndex > pos) {\n          nodes.push({\n            type: 'text',\n            content: text.slice(pos, m.index + m[1].length),\n            level: level\n          });\n        }\n\n        nodes.push({\n          type: 'abbr_open',\n          title: state.env.abbreviations[':' + m[2]],\n          level: level++\n        });\n        nodes.push({\n          type: 'text',\n          content: m[2],\n          level: level\n        });\n        nodes.push({\n          type: 'abbr_close',\n          level: --level\n        });\n        pos = reg.lastIndex - m[3].length;\n      }\n\n      if (!nodes.length) {\n        continue;\n      }\n\n      if (pos < text.length) {\n        nodes.push({\n          type: 'text',\n          content: text.slice(pos),\n          level: level\n        });\n      } // replace current node\n\n\n      blockTokens[j].children = tokens = [].concat(tokens.slice(0, i), nodes, tokens.slice(i + 1));\n    }\n  }\n} // Simple typographical replacements\n//\n// TODO:\n// - fractionals 1/2, 1/4, 3/4 -> ½, ¼, ¾\n// - miltiplication 2 x 4 -> 2 × 4\n\n\nvar RARE_RE = /\\+-|\\.\\.|\\?\\?\\?\\?|!!!!|,,|--/;\nvar SCOPED_ABBR_RE = /\\((c|tm|r|p)\\)/ig;\nvar SCOPED_ABBR = {\n  'c': '©',\n  'r': '®',\n  'p': '§',\n  'tm': '™'\n};\n\nfunction replaceScopedAbbr(str) {\n  if (str.indexOf('(') < 0) {\n    return str;\n  }\n\n  return str.replace(SCOPED_ABBR_RE, function (match, name) {\n    return SCOPED_ABBR[name.toLowerCase()];\n  });\n}\n\nfunction replace(state) {\n  var i, token, text, inlineTokens, blkIdx;\n\n  if (!state.options.typographer) {\n    return;\n  }\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline') {\n      continue;\n    }\n\n    inlineTokens = state.tokens[blkIdx].children;\n\n    for (i = inlineTokens.length - 1; i >= 0; i--) {\n      token = inlineTokens[i];\n\n      if (token.type === 'text') {\n        text = token.content;\n        text = replaceScopedAbbr(text);\n\n        if (RARE_RE.test(text)) {\n          text = text.replace(/\\+-/g, '±') // .., ..., ....... -> …\n          // but ?..... & !..... -> ?.. & !..\n          .replace(/\\.{2,}/g, '…').replace(/([?!])…/g, '$1..').replace(/([?!]){4,}/g, '$1$1$1').replace(/,{2,}/g, ',') // em-dash\n          .replace(/(^|[^-])---([^-]|$)/mg, \"$1\\u2014$2\") // en-dash\n          .replace(/(^|\\s)--(\\s|$)/mg, \"$1\\u2013$2\").replace(/(^|[^-\\s])--([^-\\s]|$)/mg, \"$1\\u2013$2\");\n        }\n\n        token.content = text;\n      }\n    }\n  }\n} // Convert straight quotation marks to typographic ones\n//\n\n\nvar QUOTE_TEST_RE = /['\"]/;\nvar QUOTE_RE = /['\"]/g;\nvar PUNCT_RE = /[-\\s()\\[\\]]/;\nvar APOSTROPHE = '’'; // This function returns true if the character at `pos`\n// could be inside a word.\n\nfunction isLetter(str, pos) {\n  if (pos < 0 || pos >= str.length) {\n    return false;\n  }\n\n  return !PUNCT_RE.test(str[pos]);\n}\n\nfunction replaceAt(str, index, ch) {\n  return str.substr(0, index) + ch + str.substr(index + 1);\n}\n\nfunction smartquotes(state) {\n  /*eslint max-depth:0*/\n  var i, token, text, t, pos, max, thisLevel, lastSpace, nextSpace, item, canOpen, canClose, j, isSingle, blkIdx, tokens, stack;\n\n  if (!state.options.typographer) {\n    return;\n  }\n\n  stack = [];\n\n  for (blkIdx = state.tokens.length - 1; blkIdx >= 0; blkIdx--) {\n    if (state.tokens[blkIdx].type !== 'inline') {\n      continue;\n    }\n\n    tokens = state.tokens[blkIdx].children;\n    stack.length = 0;\n\n    for (i = 0; i < tokens.length; i++) {\n      token = tokens[i];\n\n      if (token.type !== 'text' || QUOTE_TEST_RE.test(token.text)) {\n        continue;\n      }\n\n      thisLevel = tokens[i].level;\n\n      for (j = stack.length - 1; j >= 0; j--) {\n        if (stack[j].level <= thisLevel) {\n          break;\n        }\n      }\n\n      stack.length = j + 1;\n      text = token.content;\n      pos = 0;\n      max = text.length;\n      /*eslint no-labels:0,block-scoped-var:0*/\n\n      OUTER: while (pos < max) {\n        QUOTE_RE.lastIndex = pos;\n        t = QUOTE_RE.exec(text);\n\n        if (!t) {\n          break;\n        }\n\n        lastSpace = !isLetter(text, t.index - 1);\n        pos = t.index + 1;\n        isSingle = t[0] === \"'\";\n        nextSpace = !isLetter(text, pos);\n\n        if (!nextSpace && !lastSpace) {\n          // middle of word\n          if (isSingle) {\n            token.content = replaceAt(token.content, t.index, APOSTROPHE);\n          }\n\n          continue;\n        }\n\n        canOpen = !nextSpace;\n        canClose = !lastSpace;\n\n        if (canClose) {\n          // this could be a closing quote, rewind the stack to get a match\n          for (j = stack.length - 1; j >= 0; j--) {\n            item = stack[j];\n\n            if (stack[j].level < thisLevel) {\n              break;\n            }\n\n            if (item.single === isSingle && stack[j].level === thisLevel) {\n              item = stack[j];\n\n              if (isSingle) {\n                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[2]);\n                token.content = replaceAt(token.content, t.index, state.options.quotes[3]);\n              } else {\n                tokens[item.token].content = replaceAt(tokens[item.token].content, item.pos, state.options.quotes[0]);\n                token.content = replaceAt(token.content, t.index, state.options.quotes[1]);\n              }\n\n              stack.length = j;\n              continue OUTER;\n            }\n          }\n        }\n\n        if (canOpen) {\n          stack.push({\n            token: i,\n            pos: t.index,\n            single: isSingle,\n            level: thisLevel\n          });\n        } else if (canClose && isSingle) {\n          token.content = replaceAt(token.content, t.index, APOSTROPHE);\n        }\n      }\n    }\n  }\n}\n/**\n * Core parser `rules`\n */\n\n\nvar _rules = [['block', block], ['abbr', abbr], ['references', references], ['inline', inline], ['footnote_tail', footnote_block], ['abbr2', abbr2], ['replacements', replace], ['smartquotes', smartquotes]];\n/**\n * Class for top level (`core`) parser rules\n *\n * @api private\n */\n\nfunction Core() {\n  this.options = {};\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules.length; i++) {\n    this.ruler.push(_rules[i][0], _rules[i][1]);\n  }\n}\n/**\n * Process rules with the given `state`\n *\n * @param  {Object} `state`\n * @api private\n */\n\n\nCore.prototype.process = function (state) {\n  var i, l, rules;\n  rules = this.ruler.getRules('');\n\n  for (i = 0, l = rules.length; i < l; i++) {\n    rules[i](state);\n  }\n}; // Parser state class\n\n\nfunction StateBlock(src, parser, options, env, tokens) {\n  var ch, s, start, pos, len, indent, indent_found;\n  this.src = src; // Shortcuts to simplify nested calls\n\n  this.parser = parser;\n  this.options = options;\n  this.env = env; //\n  // Internal state vartiables\n  //\n\n  this.tokens = tokens;\n  this.bMarks = []; // line begin offsets for fast jumps\n\n  this.eMarks = []; // line end offsets for fast jumps\n\n  this.tShift = []; // indent for each line\n  // block parser variables\n\n  this.blkIndent = 0; // required block content indent\n  // (for example, if we are in list)\n\n  this.line = 0; // line index in src\n\n  this.lineMax = 0; // lines count\n\n  this.tight = false; // loose/tight mode for lists\n\n  this.parentType = 'root'; // if `list`, block parser stops on two newlines\n\n  this.ddIndent = -1; // indent of the current dd block (-1 if there isn't any)\n\n  this.level = 0; // renderer\n\n  this.result = ''; // Create caches\n  // Generate markers.\n\n  s = this.src;\n  indent = 0;\n  indent_found = false;\n\n  for (start = pos = indent = 0, len = s.length; pos < len; pos++) {\n    ch = s.charCodeAt(pos);\n\n    if (!indent_found) {\n      if (ch === 0x20\n      /* space */\n      ) {\n          indent++;\n          continue;\n        } else {\n        indent_found = true;\n      }\n    }\n\n    if (ch === 0x0A || pos === len - 1) {\n      if (ch !== 0x0A) {\n        pos++;\n      }\n\n      this.bMarks.push(start);\n      this.eMarks.push(pos);\n      this.tShift.push(indent);\n      indent_found = false;\n      indent = 0;\n      start = pos + 1;\n    }\n  } // Push fake entry to simplify cache bounds checks\n\n\n  this.bMarks.push(s.length);\n  this.eMarks.push(s.length);\n  this.tShift.push(0);\n  this.lineMax = this.bMarks.length - 1; // don't count last fake line\n}\n\nStateBlock.prototype.isEmpty = function isEmpty(line) {\n  return this.bMarks[line] + this.tShift[line] >= this.eMarks[line];\n};\n\nStateBlock.prototype.skipEmptyLines = function skipEmptyLines(from) {\n  for (var max = this.lineMax; from < max; from++) {\n    if (this.bMarks[from] + this.tShift[from] < this.eMarks[from]) {\n      break;\n    }\n  }\n\n  return from;\n}; // Skip spaces from given position.\n\n\nStateBlock.prototype.skipSpaces = function skipSpaces(pos) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== 0x20\n    /* space */\n    ) {\n        break;\n      }\n  }\n\n  return pos;\n}; // Skip char codes from given position\n\n\nStateBlock.prototype.skipChars = function skipChars(pos, code) {\n  for (var max = this.src.length; pos < max; pos++) {\n    if (this.src.charCodeAt(pos) !== code) {\n      break;\n    }\n  }\n\n  return pos;\n}; // Skip char codes reverse from given position - 1\n\n\nStateBlock.prototype.skipCharsBack = function skipCharsBack(pos, code, min) {\n  if (pos <= min) {\n    return pos;\n  }\n\n  while (pos > min) {\n    if (code !== this.src.charCodeAt(--pos)) {\n      return pos + 1;\n    }\n  }\n\n  return pos;\n}; // cut lines range from source.\n\n\nStateBlock.prototype.getLines = function getLines(begin, end, indent, keepLastLF) {\n  var i,\n      first,\n      last,\n      queue,\n      shift,\n      line = begin;\n\n  if (begin >= end) {\n    return '';\n  } // Opt: don't use push queue for single line;\n\n\n  if (line + 1 === end) {\n    first = this.bMarks[line] + Math.min(this.tShift[line], indent);\n    last = keepLastLF ? this.eMarks[line] + 1 : this.eMarks[line];\n    return this.src.slice(first, last);\n  }\n\n  queue = new Array(end - begin);\n\n  for (i = 0; line < end; line++, i++) {\n    shift = this.tShift[line];\n\n    if (shift > indent) {\n      shift = indent;\n    }\n\n    if (shift < 0) {\n      shift = 0;\n    }\n\n    first = this.bMarks[line] + shift;\n\n    if (line + 1 < end || keepLastLF) {\n      // No need for bounds check because we have fake entry on tail.\n      last = this.eMarks[line] + 1;\n    } else {\n      last = this.eMarks[line];\n    }\n\n    queue[i] = this.src.slice(first, last);\n  }\n\n  return queue.join('');\n}; // Code block (4 spaces padded)\n\n\nfunction code(state, startLine, endLine\n/*, silent*/\n) {\n  var nextLine, last;\n\n  if (state.tShift[startLine] - state.blkIndent < 4) {\n    return false;\n  }\n\n  last = nextLine = startLine + 1;\n\n  while (nextLine < endLine) {\n    if (state.isEmpty(nextLine)) {\n      nextLine++;\n      continue;\n    }\n\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      nextLine++;\n      last = nextLine;\n      continue;\n    }\n\n    break;\n  }\n\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'code',\n    content: state.getLines(startLine, last, 4 + state.blkIndent, true),\n    block: true,\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  return true;\n} // fences (``` lang, ~~~ lang)\n\n\nfunction fences(state, startLine, endLine, silent) {\n  var marker,\n      len,\n      params,\n      nextLine,\n      mem,\n      haveEndMarker = false,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 3 > max) {\n    return false;\n  }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x7E\n  /* ~ */\n  && marker !== 0x60\n  /* ` */\n  ) {\n      return false;\n    } // scan marker length\n\n\n  mem = pos;\n  pos = state.skipChars(pos, marker);\n  len = pos - mem;\n\n  if (len < 3) {\n    return false;\n  }\n\n  params = state.src.slice(pos, max).trim();\n\n  if (params.indexOf('`') >= 0) {\n    return false;\n  } // Since start is found, we can report success here in validation mode\n\n\n  if (silent) {\n    return true;\n  } // search end of block\n\n\n  nextLine = startLine;\n\n  for (;;) {\n    nextLine++;\n\n    if (nextLine >= endLine) {\n      // unclosed block should be autoclosed by end of document.\n      // also block seems to be autoclosed by end of parent\n      break;\n    }\n\n    pos = mem = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos < max && state.tShift[nextLine] < state.blkIndent) {\n      // non-empty line with negative indent should stop the list:\n      // - ```\n      //  test\n      break;\n    }\n\n    if (state.src.charCodeAt(pos) !== marker) {\n      continue;\n    }\n\n    if (state.tShift[nextLine] - state.blkIndent >= 4) {\n      // closing fence should be indented less than 4 spaces\n      continue;\n    }\n\n    pos = state.skipChars(pos, marker); // closing code fence must be at least as long as the opening one\n\n    if (pos - mem < len) {\n      continue;\n    } // make sure tail has spaces only\n\n\n    pos = state.skipSpaces(pos);\n\n    if (pos < max) {\n      continue;\n    }\n\n    haveEndMarker = true; // found!\n\n    break;\n  } // If a fence has heading spaces, they should be removed from its inner block\n\n\n  len = state.tShift[startLine];\n  state.line = nextLine + (haveEndMarker ? 1 : 0);\n  state.tokens.push({\n    type: 'fence',\n    params: params,\n    content: state.getLines(startLine + 1, nextLine, len, true),\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  return true;\n} // Block quotes\n\n\nfunction blockquote(state, startLine, endLine, silent) {\n  var nextLine,\n      lastLineEmpty,\n      oldTShift,\n      oldBMarks,\n      oldIndent,\n      oldParentType,\n      lines,\n      terminatorRules,\n      i,\n      l,\n      terminate,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos > max) {\n    return false;\n  } // check the block quote marker\n\n\n  if (state.src.charCodeAt(pos++) !== 0x3E\n  /* > */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  } // we know that it's going to be a valid blockquote,\n  // so no point trying to find the end of it in silent mode\n\n\n  if (silent) {\n    return true;\n  } // skip one optional space after '>'\n\n\n  if (state.src.charCodeAt(pos) === 0x20) {\n    pos++;\n  }\n\n  oldIndent = state.blkIndent;\n  state.blkIndent = 0;\n  oldBMarks = [state.bMarks[startLine]];\n  state.bMarks[startLine] = pos; // check if we have an empty blockquote\n\n  pos = pos < max ? state.skipSpaces(pos) : pos;\n  lastLineEmpty = pos >= max;\n  oldTShift = [state.tShift[startLine]];\n  state.tShift[startLine] = pos - state.bMarks[startLine];\n  terminatorRules = state.parser.ruler.getRules('blockquote'); // Search the end of the block\n  //\n  // Block ends with either:\n  //  1. an empty line outside:\n  //     ```\n  //     > test\n  //\n  //     ```\n  //  2. an empty line inside:\n  //     ```\n  //     >\n  //     test\n  //     ```\n  //  3. another tag\n  //     ```\n  //     > test\n  //      - - -\n  //     ```\n\n  for (nextLine = startLine + 1; nextLine < endLine; nextLine++) {\n    pos = state.bMarks[nextLine] + state.tShift[nextLine];\n    max = state.eMarks[nextLine];\n\n    if (pos >= max) {\n      // Case 1: line is not inside the blockquote, and this line is empty.\n      break;\n    }\n\n    if (state.src.charCodeAt(pos++) === 0x3E\n    /* > */\n    ) {\n        // This line is inside the blockquote.\n        // skip one optional space after '>'\n        if (state.src.charCodeAt(pos) === 0x20) {\n          pos++;\n        }\n\n        oldBMarks.push(state.bMarks[nextLine]);\n        state.bMarks[nextLine] = pos;\n        pos = pos < max ? state.skipSpaces(pos) : pos;\n        lastLineEmpty = pos >= max;\n        oldTShift.push(state.tShift[nextLine]);\n        state.tShift[nextLine] = pos - state.bMarks[nextLine];\n        continue;\n      } // Case 2: line is not inside the blockquote, and the last line was empty.\n\n\n    if (lastLineEmpty) {\n      break;\n    } // Case 3: another tag found.\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    }\n\n    oldBMarks.push(state.bMarks[nextLine]);\n    oldTShift.push(state.tShift[nextLine]); // A negative number means that this is a paragraph continuation;\n    //\n    // Any negative number will do the job here, but it's better for it\n    // to be large enough to make any bugs obvious.\n\n    state.tShift[nextLine] = -1337;\n  }\n\n  oldParentType = state.parentType;\n  state.parentType = 'blockquote';\n  state.tokens.push({\n    type: 'blockquote_open',\n    lines: lines = [startLine, 0],\n    level: state.level++\n  });\n  state.parser.tokenize(state, startLine, nextLine);\n  state.tokens.push({\n    type: 'blockquote_close',\n    level: --state.level\n  });\n  state.parentType = oldParentType;\n  lines[1] = state.line; // Restore original tShift; this might not be necessary since the parser\n  // has already been here, but just to make sure we can do that.\n\n  for (i = 0; i < oldTShift.length; i++) {\n    state.bMarks[i + startLine] = oldBMarks[i];\n    state.tShift[i + startLine] = oldTShift[i];\n  }\n\n  state.blkIndent = oldIndent;\n  return true;\n} // Horizontal rule\n\n\nfunction hr(state, startLine, endLine, silent) {\n  var marker,\n      cnt,\n      ch,\n      pos = state.bMarks[startLine],\n      max = state.eMarks[startLine];\n  pos += state.tShift[startLine];\n\n  if (pos > max) {\n    return false;\n  }\n\n  marker = state.src.charCodeAt(pos++); // Check hr marker\n\n  if (marker !== 0x2A\n  /* * */\n  && marker !== 0x2D\n  /* - */\n  && marker !== 0x5F\n  /* _ */\n  ) {\n      return false;\n    } // markers can be mixed with spaces, but there should be at least 3 one\n\n\n  cnt = 1;\n\n  while (pos < max) {\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch !== marker && ch !== 0x20\n    /* space */\n    ) {\n        return false;\n      }\n\n    if (ch === marker) {\n      cnt++;\n    }\n  }\n\n  if (cnt < 3) {\n    return false;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  state.line = startLine + 1;\n  state.tokens.push({\n    type: 'hr',\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  return true;\n} // Lists\n// Search `[-+*][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\n\n\nfunction skipBulletListMarker(state, startLine) {\n  var marker, pos, max;\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  max = state.eMarks[startLine];\n\n  if (pos >= max) {\n    return -1;\n  }\n\n  marker = state.src.charCodeAt(pos++); // Check bullet\n\n  if (marker !== 0x2A\n  /* * */\n  && marker !== 0x2D\n  /* - */\n  && marker !== 0x2B\n  /* + */\n  ) {\n      return -1;\n    }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20) {\n    // \" 1.test \" - is not a list item\n    return -1;\n  }\n\n  return pos;\n} // Search `\\d+[.)][\\n ]`, returns next pos arter marker on success\n// or -1 on fail.\n\n\nfunction skipOrderedListMarker(state, startLine) {\n  var ch,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos + 1 >= max) {\n    return -1;\n  }\n\n  ch = state.src.charCodeAt(pos++);\n\n  if (ch < 0x30\n  /* 0 */\n  || ch > 0x39\n  /* 9 */\n  ) {\n      return -1;\n    }\n\n  for (;;) {\n    // EOL -> fail\n    if (pos >= max) {\n      return -1;\n    }\n\n    ch = state.src.charCodeAt(pos++);\n\n    if (ch >= 0x30\n    /* 0 */\n    && ch <= 0x39\n    /* 9 */\n    ) {\n        continue;\n      } // found valid marker\n\n\n    if (ch === 0x29\n    /* ) */\n    || ch === 0x2e\n    /* . */\n    ) {\n        break;\n      }\n\n    return -1;\n  }\n\n  if (pos < max && state.src.charCodeAt(pos) !== 0x20\n  /* space */\n  ) {\n      // \" 1.test \" - is not a list item\n      return -1;\n    }\n\n  return pos;\n}\n\nfunction markTightParagraphs(state, idx) {\n  var i,\n      l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nfunction list(state, startLine, endLine, silent) {\n  var nextLine,\n      indent,\n      oldTShift,\n      oldIndent,\n      oldTight,\n      oldParentType,\n      start,\n      posAfterMarker,\n      max,\n      indentAfterMarker,\n      markerValue,\n      markerCharCode,\n      isOrdered,\n      contentStart,\n      listTokIdx,\n      prevEmptyEnd,\n      listLines,\n      itemLines,\n      tight = true,\n      terminatorRules,\n      i,\n      l,\n      terminate; // Detect list type and position after marker\n\n  if ((posAfterMarker = skipOrderedListMarker(state, startLine)) >= 0) {\n    isOrdered = true;\n  } else if ((posAfterMarker = skipBulletListMarker(state, startLine)) >= 0) {\n    isOrdered = false;\n  } else {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  } // We should terminate list on style change. Remember first one to compare.\n\n\n  markerCharCode = state.src.charCodeAt(posAfterMarker - 1); // For validation mode we can terminate immediately\n\n  if (silent) {\n    return true;\n  } // Start list\n\n\n  listTokIdx = state.tokens.length;\n\n  if (isOrdered) {\n    start = state.bMarks[startLine] + state.tShift[startLine];\n    markerValue = Number(state.src.substr(start, posAfterMarker - start - 1));\n    state.tokens.push({\n      type: 'ordered_list_open',\n      order: markerValue,\n      lines: listLines = [startLine, 0],\n      level: state.level++\n    });\n  } else {\n    state.tokens.push({\n      type: 'bullet_list_open',\n      lines: listLines = [startLine, 0],\n      level: state.level++\n    });\n  } //\n  // Iterate list items\n  //\n\n\n  nextLine = startLine;\n  prevEmptyEnd = false;\n  terminatorRules = state.parser.ruler.getRules('list');\n\n  while (nextLine < endLine) {\n    contentStart = state.skipSpaces(posAfterMarker);\n    max = state.eMarks[nextLine];\n\n    if (contentStart >= max) {\n      // trimming space in \"-    \\n  3\" case, indent is 1 here\n      indentAfterMarker = 1;\n    } else {\n      indentAfterMarker = contentStart - posAfterMarker;\n    } // If we have more than 4 spaces, the indent is 1\n    // (the rest is just indented code block)\n\n\n    if (indentAfterMarker > 4) {\n      indentAfterMarker = 1;\n    } // If indent is less than 1, assume that it's one, example:\n    //  \"-\\n  test\"\n\n\n    if (indentAfterMarker < 1) {\n      indentAfterMarker = 1;\n    } // \"  -  test\"\n    //  ^^^^^ - calculating total length of this thing\n\n\n    indent = posAfterMarker - state.bMarks[nextLine] + indentAfterMarker; // Run subparser & write tokens\n\n    state.tokens.push({\n      type: 'list_item_open',\n      lines: itemLines = [startLine, 0],\n      level: state.level++\n    });\n    oldIndent = state.blkIndent;\n    oldTight = state.tight;\n    oldTShift = state.tShift[startLine];\n    oldParentType = state.parentType;\n    state.tShift[startLine] = contentStart - state.bMarks[startLine];\n    state.blkIndent = indent;\n    state.tight = true;\n    state.parentType = 'list';\n    state.parser.tokenize(state, startLine, endLine, true); // If any of list item is tight, mark list as tight\n\n    if (!state.tight || prevEmptyEnd) {\n      tight = false;\n    } // Item become loose if finish with empty line,\n    // but we should filter last element, because it means list finish\n\n\n    prevEmptyEnd = state.line - startLine > 1 && state.isEmpty(state.line - 1);\n    state.blkIndent = oldIndent;\n    state.tShift[startLine] = oldTShift;\n    state.tight = oldTight;\n    state.parentType = oldParentType;\n    state.tokens.push({\n      type: 'list_item_close',\n      level: --state.level\n    });\n    nextLine = startLine = state.line;\n    itemLines[1] = nextLine;\n    contentStart = state.bMarks[startLine];\n\n    if (nextLine >= endLine) {\n      break;\n    }\n\n    if (state.isEmpty(nextLine)) {\n      break;\n    } //\n    // Try to check if list is terminated or continued.\n    //\n\n\n    if (state.tShift[nextLine] < state.blkIndent) {\n      break;\n    } // fail if terminating block found\n\n\n    terminate = false;\n\n    for (i = 0, l = terminatorRules.length; i < l; i++) {\n      if (terminatorRules[i](state, nextLine, endLine, true)) {\n        terminate = true;\n        break;\n      }\n    }\n\n    if (terminate) {\n      break;\n    } // fail if list has another type\n\n\n    if (isOrdered) {\n      posAfterMarker = skipOrderedListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    } else {\n      posAfterMarker = skipBulletListMarker(state, nextLine);\n\n      if (posAfterMarker < 0) {\n        break;\n      }\n    }\n\n    if (markerCharCode !== state.src.charCodeAt(posAfterMarker - 1)) {\n      break;\n    }\n  } // Finilize list\n\n\n  state.tokens.push({\n    type: isOrdered ? 'ordered_list_close' : 'bullet_list_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n  state.line = nextLine; // mark paragraphs tight if needed\n\n  if (tight) {\n    markTightParagraphs(state, listTokIdx);\n  }\n\n  return true;\n} // Process footnote reference list\n\n\nfunction footnote(state, startLine, endLine, silent) {\n  var oldBMark,\n      oldTShift,\n      oldParentType,\n      pos,\n      label,\n      start = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine]; // line should be at least 5 chars - \"[^x]:\"\n\n  if (start + 4 > max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start) !== 0x5B\n  /* [ */\n  ) {\n      return false;\n    }\n\n  if (state.src.charCodeAt(start + 1) !== 0x5E\n  /* ^ */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  for (pos = start + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x20) {\n      return false;\n    }\n\n    if (state.src.charCodeAt(pos) === 0x5D\n    /* ] */\n    ) {\n        break;\n      }\n  }\n\n  if (pos === start + 2) {\n    return false;\n  } // no empty footnote labels\n\n\n  if (pos + 1 >= max || state.src.charCodeAt(++pos) !== 0x3A\n  /* : */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return true;\n  }\n\n  pos++;\n\n  if (!state.env.footnotes) {\n    state.env.footnotes = {};\n  }\n\n  if (!state.env.footnotes.refs) {\n    state.env.footnotes.refs = {};\n  }\n\n  label = state.src.slice(start + 2, pos - 2);\n  state.env.footnotes.refs[':' + label] = -1;\n  state.tokens.push({\n    type: 'footnote_reference_open',\n    label: label,\n    level: state.level++\n  });\n  oldBMark = state.bMarks[startLine];\n  oldTShift = state.tShift[startLine];\n  oldParentType = state.parentType;\n  state.tShift[startLine] = state.skipSpaces(pos) - pos;\n  state.bMarks[startLine] = pos;\n  state.blkIndent += 4;\n  state.parentType = 'footnote';\n\n  if (state.tShift[startLine] < state.blkIndent) {\n    state.tShift[startLine] += state.blkIndent;\n    state.bMarks[startLine] -= state.blkIndent;\n  }\n\n  state.parser.tokenize(state, startLine, endLine, true);\n  state.parentType = oldParentType;\n  state.blkIndent -= 4;\n  state.tShift[startLine] = oldTShift;\n  state.bMarks[startLine] = oldBMark;\n  state.tokens.push({\n    type: 'footnote_reference_close',\n    level: --state.level\n  });\n  return true;\n} // heading (#, ##, ...)\n\n\nfunction heading(state, startLine, endLine, silent) {\n  var ch,\n      level,\n      tmp,\n      pos = state.bMarks[startLine] + state.tShift[startLine],\n      max = state.eMarks[startLine];\n\n  if (pos >= max) {\n    return false;\n  }\n\n  ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x23\n  /* # */\n  || pos >= max) {\n    return false;\n  } // count heading level\n\n\n  level = 1;\n  ch = state.src.charCodeAt(++pos);\n\n  while (ch === 0x23\n  /* # */\n  && pos < max && level <= 6) {\n    level++;\n    ch = state.src.charCodeAt(++pos);\n  }\n\n  if (level > 6 || pos < max && ch !== 0x20\n  /* space */\n  ) {\n    return false;\n  }\n\n  if (silent) {\n    return true;\n  } // Let's cut tails like '    ###  ' from the end of string\n\n\n  max = state.skipCharsBack(max, 0x20, pos); // space\n\n  tmp = state.skipCharsBack(max, 0x23, pos); // #\n\n  if (tmp > pos && state.src.charCodeAt(tmp - 1) === 0x20\n  /* space */\n  ) {\n      max = tmp;\n    }\n\n  state.line = startLine + 1;\n  state.tokens.push({\n    type: 'heading_open',\n    hLevel: level,\n    lines: [startLine, state.line],\n    level: state.level\n  }); // only if header is not empty\n\n  if (pos < max) {\n    state.tokens.push({\n      type: 'inline',\n      content: state.src.slice(pos, max).trim(),\n      level: state.level + 1,\n      lines: [startLine, state.line],\n      children: []\n    });\n  }\n\n  state.tokens.push({\n    type: 'heading_close',\n    hLevel: level,\n    level: state.level\n  });\n  return true;\n} // lheading (---, ===)\n\n\nfunction lheading(state, startLine, endLine\n/*, silent*/\n) {\n  var marker,\n      pos,\n      max,\n      next = startLine + 1;\n\n  if (next >= endLine) {\n    return false;\n  }\n\n  if (state.tShift[next] < state.blkIndent) {\n    return false;\n  } // Scan next line\n\n\n  if (state.tShift[next] - state.blkIndent > 3) {\n    return false;\n  }\n\n  pos = state.bMarks[next] + state.tShift[next];\n  max = state.eMarks[next];\n\n  if (pos >= max) {\n    return false;\n  }\n\n  marker = state.src.charCodeAt(pos);\n\n  if (marker !== 0x2D\n  /* - */\n  && marker !== 0x3D\n  /* = */\n  ) {\n      return false;\n    }\n\n  pos = state.skipChars(pos, marker);\n  pos = state.skipSpaces(pos);\n\n  if (pos < max) {\n    return false;\n  }\n\n  pos = state.bMarks[startLine] + state.tShift[startLine];\n  state.line = next + 1;\n  state.tokens.push({\n    type: 'heading_open',\n    hLevel: marker === 0x3D\n    /* = */\n    ? 1 : 2,\n    lines: [startLine, state.line],\n    level: state.level\n  });\n  state.tokens.push({\n    type: 'inline',\n    content: state.src.slice(pos, state.eMarks[startLine]).trim(),\n    level: state.level + 1,\n    lines: [startLine, state.line - 1],\n    children: []\n  });\n  state.tokens.push({\n    type: 'heading_close',\n    hLevel: marker === 0x3D\n    /* = */\n    ? 1 : 2,\n    level: state.level\n  });\n  return true;\n} // List of valid html blocks names, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#html-blocks\n\n\nvar html_blocks = {};\n['article', 'aside', 'button', 'blockquote', 'body', 'canvas', 'caption', 'col', 'colgroup', 'dd', 'div', 'dl', 'dt', 'embed', 'fieldset', 'figcaption', 'figure', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'iframe', 'li', 'map', 'object', 'ol', 'output', 'p', 'pre', 'progress', 'script', 'section', 'style', 'table', 'tbody', 'td', 'textarea', 'tfoot', 'th', 'tr', 'thead', 'ul', 'video'].forEach(function (name) {\n  html_blocks[name] = true;\n}); // HTML block\n\nvar HTML_TAG_OPEN_RE = /^<([a-zA-Z]{1,15})[\\s\\/>]/;\nvar HTML_TAG_CLOSE_RE = /^<\\/([a-zA-Z]{1,15})[\\s>]/;\n\nfunction isLetter$1(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n\n  return lc >= 0x61\n  /* a */\n  && lc <= 0x7a\n  /* z */\n  ;\n}\n\nfunction htmlblock(state, startLine, endLine, silent) {\n  var ch,\n      match,\n      nextLine,\n      pos = state.bMarks[startLine],\n      max = state.eMarks[startLine],\n      shift = state.tShift[startLine];\n  pos += shift;\n\n  if (!state.options.html) {\n    return false;\n  }\n\n  if (shift > 3 || pos + 2 >= max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(pos) !== 0x3C\n  /* < */\n  ) {\n      return false;\n    }\n\n  ch = state.src.charCodeAt(pos + 1);\n\n  if (ch === 0x21\n  /* ! */\n  || ch === 0x3F\n  /* ? */\n  ) {\n      // Directive start / comment start / processing instruction start\n      if (silent) {\n        return true;\n      }\n    } else if (ch === 0x2F\n  /* / */\n  || isLetter$1(ch)) {\n    // Probably start or end of tag\n    if (ch === 0x2F\n    /* \\ */\n    ) {\n        // closing tag\n        match = state.src.slice(pos, max).match(HTML_TAG_CLOSE_RE);\n\n        if (!match) {\n          return false;\n        }\n      } else {\n      // opening tag\n      match = state.src.slice(pos, max).match(HTML_TAG_OPEN_RE);\n\n      if (!match) {\n        return false;\n      }\n    } // Make sure tag name is valid\n\n\n    if (html_blocks[match[1].toLowerCase()] !== true) {\n      return false;\n    }\n\n    if (silent) {\n      return true;\n    }\n  } else {\n    return false;\n  } // If we are here - we detected HTML block.\n  // Let's roll down till empty line (block end).\n\n\n  nextLine = startLine + 1;\n\n  while (nextLine < state.lineMax && !state.isEmpty(nextLine)) {\n    nextLine++;\n  }\n\n  state.line = nextLine;\n  state.tokens.push({\n    type: 'htmlblock',\n    level: state.level,\n    lines: [startLine, state.line],\n    content: state.getLines(startLine, nextLine, 0, true)\n  });\n  return true;\n} // GFM table, non-standard\n\n\nfunction getLine(state, line) {\n  var pos = state.bMarks[line] + state.blkIndent,\n      max = state.eMarks[line];\n  return state.src.substr(pos, max - pos);\n}\n\nfunction table(state, startLine, endLine, silent) {\n  var ch, lineText, pos, i, nextLine, rows, cell, aligns, t, tableLines, tbodyLines; // should have at least three lines\n\n  if (startLine + 2 > endLine) {\n    return false;\n  }\n\n  nextLine = startLine + 1;\n\n  if (state.tShift[nextLine] < state.blkIndent) {\n    return false;\n  } // first character of the second line should be '|' or '-'\n\n\n  pos = state.bMarks[nextLine] + state.tShift[nextLine];\n\n  if (pos >= state.eMarks[nextLine]) {\n    return false;\n  }\n\n  ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x7C\n  /* | */\n  && ch !== 0x2D\n  /* - */\n  && ch !== 0x3A\n  /* : */\n  ) {\n      return false;\n    }\n\n  lineText = getLine(state, startLine + 1);\n\n  if (!/^[-:| ]+$/.test(lineText)) {\n    return false;\n  }\n\n  rows = lineText.split('|');\n\n  if (rows <= 2) {\n    return false;\n  }\n\n  aligns = [];\n\n  for (i = 0; i < rows.length; i++) {\n    t = rows[i].trim();\n\n    if (!t) {\n      // allow empty columns before and after table, but not in between columns;\n      // e.g. allow ` |---| `, disallow ` ---||--- `\n      if (i === 0 || i === rows.length - 1) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n\n    if (!/^:?-+:?$/.test(t)) {\n      return false;\n    }\n\n    if (t.charCodeAt(t.length - 1) === 0x3A\n    /* : */\n    ) {\n        aligns.push(t.charCodeAt(0) === 0x3A\n        /* : */\n        ? 'center' : 'right');\n      } else if (t.charCodeAt(0) === 0x3A\n    /* : */\n    ) {\n        aligns.push('left');\n      } else {\n      aligns.push('');\n    }\n  }\n\n  lineText = getLine(state, startLine).trim();\n\n  if (lineText.indexOf('|') === -1) {\n    return false;\n  }\n\n  rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n\n  if (aligns.length !== rows.length) {\n    return false;\n  }\n\n  if (silent) {\n    return true;\n  }\n\n  state.tokens.push({\n    type: 'table_open',\n    lines: tableLines = [startLine, 0],\n    level: state.level++\n  });\n  state.tokens.push({\n    type: 'thead_open',\n    lines: [startLine, startLine + 1],\n    level: state.level++\n  });\n  state.tokens.push({\n    type: 'tr_open',\n    lines: [startLine, startLine + 1],\n    level: state.level++\n  });\n\n  for (i = 0; i < rows.length; i++) {\n    state.tokens.push({\n      type: 'th_open',\n      align: aligns[i],\n      lines: [startLine, startLine + 1],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: rows[i].trim(),\n      lines: [startLine, startLine + 1],\n      level: state.level,\n      children: []\n    });\n    state.tokens.push({\n      type: 'th_close',\n      level: --state.level\n    });\n  }\n\n  state.tokens.push({\n    type: 'tr_close',\n    level: --state.level\n  });\n  state.tokens.push({\n    type: 'thead_close',\n    level: --state.level\n  });\n  state.tokens.push({\n    type: 'tbody_open',\n    lines: tbodyLines = [startLine + 2, 0],\n    level: state.level++\n  });\n\n  for (nextLine = startLine + 2; nextLine < endLine; nextLine++) {\n    if (state.tShift[nextLine] < state.blkIndent) {\n      break;\n    }\n\n    lineText = getLine(state, nextLine).trim();\n\n    if (lineText.indexOf('|') === -1) {\n      break;\n    }\n\n    rows = lineText.replace(/^\\||\\|$/g, '').split('|');\n    state.tokens.push({\n      type: 'tr_open',\n      level: state.level++\n    });\n\n    for (i = 0; i < rows.length; i++) {\n      state.tokens.push({\n        type: 'td_open',\n        align: aligns[i],\n        level: state.level++\n      }); // 0x7c === '|'\n\n      cell = rows[i].substring(rows[i].charCodeAt(0) === 0x7c ? 1 : 0, rows[i].charCodeAt(rows[i].length - 1) === 0x7c ? rows[i].length - 1 : rows[i].length).trim();\n      state.tokens.push({\n        type: 'inline',\n        content: cell,\n        level: state.level,\n        children: []\n      });\n      state.tokens.push({\n        type: 'td_close',\n        level: --state.level\n      });\n    }\n\n    state.tokens.push({\n      type: 'tr_close',\n      level: --state.level\n    });\n  }\n\n  state.tokens.push({\n    type: 'tbody_close',\n    level: --state.level\n  });\n  state.tokens.push({\n    type: 'table_close',\n    level: --state.level\n  });\n  tableLines[1] = tbodyLines[1] = nextLine;\n  state.line = nextLine;\n  return true;\n} // Definition lists\n// Search `[:~][\\n ]`, returns next pos after marker on success\n// or -1 on fail.\n\n\nfunction skipMarker(state, line) {\n  var pos,\n      marker,\n      start = state.bMarks[line] + state.tShift[line],\n      max = state.eMarks[line];\n\n  if (start >= max) {\n    return -1;\n  } // Check bullet\n\n\n  marker = state.src.charCodeAt(start++);\n\n  if (marker !== 0x7E\n  /* ~ */\n  && marker !== 0x3A\n  /* : */\n  ) {\n      return -1;\n    }\n\n  pos = state.skipSpaces(start); // require space after \":\"\n\n  if (start === pos) {\n    return -1;\n  } // no empty definitions, e.g. \"  : \"\n\n\n  if (pos >= max) {\n    return -1;\n  }\n\n  return pos;\n}\n\nfunction markTightParagraphs$1(state, idx) {\n  var i,\n      l,\n      level = state.level + 2;\n\n  for (i = idx + 2, l = state.tokens.length - 2; i < l; i++) {\n    if (state.tokens[i].level === level && state.tokens[i].type === 'paragraph_open') {\n      state.tokens[i + 2].tight = true;\n      state.tokens[i].tight = true;\n      i += 2;\n    }\n  }\n}\n\nfunction deflist(state, startLine, endLine, silent) {\n  var contentStart, ddLine, dtLine, itemLines, listLines, listTokIdx, nextLine, oldIndent, oldDDIndent, oldParentType, oldTShift, oldTight, prevEmptyEnd, tight;\n\n  if (silent) {\n    // quirk: validation mode validates a dd block only, not a whole deflist\n    if (state.ddIndent < 0) {\n      return false;\n    }\n\n    return skipMarker(state, startLine) >= 0;\n  }\n\n  nextLine = startLine + 1;\n\n  if (state.isEmpty(nextLine)) {\n    if (++nextLine > endLine) {\n      return false;\n    }\n  }\n\n  if (state.tShift[nextLine] < state.blkIndent) {\n    return false;\n  }\n\n  contentStart = skipMarker(state, nextLine);\n\n  if (contentStart < 0) {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  } // Start list\n\n\n  listTokIdx = state.tokens.length;\n  state.tokens.push({\n    type: 'dl_open',\n    lines: listLines = [startLine, 0],\n    level: state.level++\n  }); //\n  // Iterate list items\n  //\n\n  dtLine = startLine;\n  ddLine = nextLine; // One definition list can contain multiple DTs,\n  // and one DT can be followed by multiple DDs.\n  //\n  // Thus, there is two loops here, and label is\n  // needed to break out of the second one\n  //\n\n  /*eslint no-labels:0,block-scoped-var:0*/\n\n  OUTER: for (;;) {\n    tight = true;\n    prevEmptyEnd = false;\n    state.tokens.push({\n      type: 'dt_open',\n      lines: [dtLine, dtLine],\n      level: state.level++\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: state.getLines(dtLine, dtLine + 1, state.blkIndent, false).trim(),\n      level: state.level + 1,\n      lines: [dtLine, dtLine],\n      children: []\n    });\n    state.tokens.push({\n      type: 'dt_close',\n      level: --state.level\n    });\n\n    for (;;) {\n      state.tokens.push({\n        type: 'dd_open',\n        lines: itemLines = [nextLine, 0],\n        level: state.level++\n      });\n      oldTight = state.tight;\n      oldDDIndent = state.ddIndent;\n      oldIndent = state.blkIndent;\n      oldTShift = state.tShift[ddLine];\n      oldParentType = state.parentType;\n      state.blkIndent = state.ddIndent = state.tShift[ddLine] + 2;\n      state.tShift[ddLine] = contentStart - state.bMarks[ddLine];\n      state.tight = true;\n      state.parentType = 'deflist';\n      state.parser.tokenize(state, ddLine, endLine, true); // If any of list item is tight, mark list as tight\n\n      if (!state.tight || prevEmptyEnd) {\n        tight = false;\n      } // Item become loose if finish with empty line,\n      // but we should filter last element, because it means list finish\n\n\n      prevEmptyEnd = state.line - ddLine > 1 && state.isEmpty(state.line - 1);\n      state.tShift[ddLine] = oldTShift;\n      state.tight = oldTight;\n      state.parentType = oldParentType;\n      state.blkIndent = oldIndent;\n      state.ddIndent = oldDDIndent;\n      state.tokens.push({\n        type: 'dd_close',\n        level: --state.level\n      });\n      itemLines[1] = nextLine = state.line;\n\n      if (nextLine >= endLine) {\n        break OUTER;\n      }\n\n      if (state.tShift[nextLine] < state.blkIndent) {\n        break OUTER;\n      }\n\n      contentStart = skipMarker(state, nextLine);\n\n      if (contentStart < 0) {\n        break;\n      }\n\n      ddLine = nextLine; // go to the next loop iteration:\n      // insert DD tag and repeat checking\n    }\n\n    if (nextLine >= endLine) {\n      break;\n    }\n\n    dtLine = nextLine;\n\n    if (state.isEmpty(dtLine)) {\n      break;\n    }\n\n    if (state.tShift[dtLine] < state.blkIndent) {\n      break;\n    }\n\n    ddLine = dtLine + 1;\n\n    if (ddLine >= endLine) {\n      break;\n    }\n\n    if (state.isEmpty(ddLine)) {\n      ddLine++;\n    }\n\n    if (ddLine >= endLine) {\n      break;\n    }\n\n    if (state.tShift[ddLine] < state.blkIndent) {\n      break;\n    }\n\n    contentStart = skipMarker(state, ddLine);\n\n    if (contentStart < 0) {\n      break;\n    } // go to the next loop iteration:\n    // insert DT and DD tags and repeat checking\n\n  } // Finilize list\n\n\n  state.tokens.push({\n    type: 'dl_close',\n    level: --state.level\n  });\n  listLines[1] = nextLine;\n  state.line = nextLine; // mark paragraphs tight if needed\n\n  if (tight) {\n    markTightParagraphs$1(state, listTokIdx);\n  }\n\n  return true;\n} // Paragraph\n\n\nfunction paragraph(state, startLine\n/*, endLine*/\n) {\n  var endLine,\n      content,\n      terminate,\n      i,\n      l,\n      nextLine = startLine + 1,\n      terminatorRules;\n  endLine = state.lineMax; // jump line-by-line until empty one or EOF\n\n  if (nextLine < endLine && !state.isEmpty(nextLine)) {\n    terminatorRules = state.parser.ruler.getRules('paragraph');\n\n    for (; nextLine < endLine && !state.isEmpty(nextLine); nextLine++) {\n      // this would be a code block normally, but after paragraph\n      // it's considered a lazy continuation regardless of what's there\n      if (state.tShift[nextLine] - state.blkIndent > 3) {\n        continue;\n      } // Some tags can terminate paragraph without empty line.\n\n\n      terminate = false;\n\n      for (i = 0, l = terminatorRules.length; i < l; i++) {\n        if (terminatorRules[i](state, nextLine, endLine, true)) {\n          terminate = true;\n          break;\n        }\n      }\n\n      if (terminate) {\n        break;\n      }\n    }\n  }\n\n  content = state.getLines(startLine, nextLine, state.blkIndent, false).trim();\n  state.line = nextLine;\n\n  if (content.length) {\n    state.tokens.push({\n      type: 'paragraph_open',\n      tight: false,\n      lines: [startLine, state.line],\n      level: state.level\n    });\n    state.tokens.push({\n      type: 'inline',\n      content: content,\n      level: state.level + 1,\n      lines: [startLine, state.line],\n      children: []\n    });\n    state.tokens.push({\n      type: 'paragraph_close',\n      tight: false,\n      level: state.level\n    });\n  }\n\n  return true;\n}\n/**\n * Parser rules\n */\n\n\nvar _rules$1 = [['code', code], ['fences', fences, ['paragraph', 'blockquote', 'list']], ['blockquote', blockquote, ['paragraph', 'blockquote', 'list']], ['hr', hr, ['paragraph', 'blockquote', 'list']], ['list', list, ['paragraph', 'blockquote']], ['footnote', footnote, ['paragraph']], ['heading', heading, ['paragraph', 'blockquote']], ['lheading', lheading], ['htmlblock', htmlblock, ['paragraph', 'blockquote']], ['table', table, ['paragraph']], ['deflist', deflist, ['paragraph']], ['paragraph', paragraph]];\n/**\n * Block Parser class\n *\n * @api private\n */\n\nfunction ParserBlock() {\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules$1.length; i++) {\n    this.ruler.push(_rules$1[i][0], _rules$1[i][1], {\n      alt: (_rules$1[i][2] || []).slice()\n    });\n  }\n}\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state` Has properties like `src`, `parser`, `options` etc\n * @param  {Number} `startLine`\n * @param  {Number} `endLine`\n * @api private\n */\n\n\nParserBlock.prototype.tokenize = function (state, startLine, endLine) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var line = startLine;\n  var hasEmptyLines = false;\n  var ok, i;\n\n  while (line < endLine) {\n    state.line = line = state.skipEmptyLines(line);\n\n    if (line >= endLine) {\n      break;\n    } // Termination condition for nested calls.\n    // Nested calls currently used for blockquotes & lists\n\n\n    if (state.tShift[line] < state.blkIndent) {\n      break;\n    } // Try all possible rules.\n    // On success, rule should:\n    //\n    // - update `state.line`\n    // - update `state.tokens`\n    // - return true\n\n\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, line, endLine, false);\n\n      if (ok) {\n        break;\n      }\n    } // set state.tight iff we had an empty line before current tag\n    // i.e. latest empty line should not count\n\n\n    state.tight = !hasEmptyLines; // paragraph might \"eat\" one newline after it in nested lists\n\n    if (state.isEmpty(state.line - 1)) {\n      hasEmptyLines = true;\n    }\n\n    line = state.line;\n\n    if (line < endLine && state.isEmpty(line)) {\n      hasEmptyLines = true;\n      line++; // two empty lines should stop the parser in list mode\n\n      if (line < endLine && state.parentType === 'list' && state.isEmpty(line)) {\n        break;\n      }\n\n      state.line = line;\n    }\n  }\n};\n\nvar TABS_SCAN_RE = /[\\n\\t]/g;\nvar NEWLINES_RE = /\\r[\\n\\u0085]|[\\u2424\\u2028\\u0085]/g;\nvar SPACES_RE = /\\u00a0/g;\n/**\n * Tokenize the given `str`.\n *\n * @param  {String} `str` Source string\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\nParserBlock.prototype.parse = function (str, options, env, outTokens) {\n  var state,\n      lineStart = 0,\n      lastTabPos = 0;\n\n  if (!str) {\n    return [];\n  } // Normalize spaces\n\n\n  str = str.replace(SPACES_RE, ' '); // Normalize newlines\n\n  str = str.replace(NEWLINES_RE, '\\n'); // Replace tabs with proper number of spaces (1..4)\n\n  if (str.indexOf('\\t') >= 0) {\n    str = str.replace(TABS_SCAN_RE, function (match, offset) {\n      var result;\n\n      if (str.charCodeAt(offset) === 0x0A) {\n        lineStart = offset + 1;\n        lastTabPos = 0;\n        return match;\n      }\n\n      result = '    '.slice((offset - lineStart - lastTabPos) % 4);\n      lastTabPos = offset - lineStart + 1;\n      return result;\n    });\n  }\n\n  state = new StateBlock(str, this, options, env, outTokens);\n  this.tokenize(state, state.line, state.lineMax);\n}; // Skip text characters for text token, place those to pending buffer\n// and increment current pos\n// Rule to skip pure text\n// '{}$%@~+=:' reserved for extentions\n\n\nfunction isTerminatorChar(ch) {\n  switch (ch) {\n    case 0x0A\n    /* \\n */\n    :\n    case 0x5C\n    /* \\ */\n    :\n    case 0x60\n    /* ` */\n    :\n    case 0x2A\n    /* * */\n    :\n    case 0x5F\n    /* _ */\n    :\n    case 0x5E\n    /* ^ */\n    :\n    case 0x5B\n    /* [ */\n    :\n    case 0x5D\n    /* ] */\n    :\n    case 0x21\n    /* ! */\n    :\n    case 0x26\n    /* & */\n    :\n    case 0x3C\n    /* < */\n    :\n    case 0x3E\n    /* > */\n    :\n    case 0x7B\n    /* { */\n    :\n    case 0x7D\n    /* } */\n    :\n    case 0x24\n    /* $ */\n    :\n    case 0x25\n    /* % */\n    :\n    case 0x40\n    /* @ */\n    :\n    case 0x7E\n    /* ~ */\n    :\n    case 0x2B\n    /* + */\n    :\n    case 0x3D\n    /* = */\n    :\n    case 0x3A\n    /* : */\n    :\n      return true;\n\n    default:\n      return false;\n  }\n}\n\nfunction text(state, silent) {\n  var pos = state.pos;\n\n  while (pos < state.posMax && !isTerminatorChar(state.src.charCodeAt(pos))) {\n    pos++;\n  }\n\n  if (pos === state.pos) {\n    return false;\n  }\n\n  if (!silent) {\n    state.pending += state.src.slice(state.pos, pos);\n  }\n\n  state.pos = pos;\n  return true;\n} // Proceess '\\n'\n\n\nfunction newline(state, silent) {\n  var pmax,\n      max,\n      pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x0A\n  /* \\n */\n  ) {\n      return false;\n    }\n\n  pmax = state.pending.length - 1;\n  max = state.posMax; // '  \\n' -> hardbreak\n  // Lookup in pending chars is bad practice! Don't copy to other rules!\n  // Pending string is stored in concat mode, indexed lookups will cause\n  // convertion to flat mode.\n\n  if (!silent) {\n    if (pmax >= 0 && state.pending.charCodeAt(pmax) === 0x20) {\n      if (pmax >= 1 && state.pending.charCodeAt(pmax - 1) === 0x20) {\n        // Strip out all trailing spaces on this line.\n        for (var i = pmax - 2; i >= 0; i--) {\n          if (state.pending.charCodeAt(i) !== 0x20) {\n            state.pending = state.pending.substring(0, i + 1);\n            break;\n          }\n        }\n\n        state.push({\n          type: 'hardbreak',\n          level: state.level\n        });\n      } else {\n        state.pending = state.pending.slice(0, -1);\n        state.push({\n          type: 'softbreak',\n          level: state.level\n        });\n      }\n    } else {\n      state.push({\n        type: 'softbreak',\n        level: state.level\n      });\n    }\n  }\n\n  pos++; // skip heading spaces for next line\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x20) {\n    pos++;\n  }\n\n  state.pos = pos;\n  return true;\n} // Proceess escaped chars and hardbreaks\n\n\nvar ESCAPED = [];\n\nfor (var i = 0; i < 256; i++) {\n  ESCAPED.push(0);\n}\n\n'\\\\!\"#$%&\\'()*+,./:;<=>?@[]^_`{|}~-'.split('').forEach(function (ch) {\n  ESCAPED[ch.charCodeAt(0)] = 1;\n});\n\nfunction escape(state, silent) {\n  var ch,\n      pos = state.pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x5C\n  /* \\ */\n  ) {\n      return false;\n    }\n\n  pos++;\n\n  if (pos < max) {\n    ch = state.src.charCodeAt(pos);\n\n    if (ch < 256 && ESCAPED[ch] !== 0) {\n      if (!silent) {\n        state.pending += state.src[pos];\n      }\n\n      state.pos += 2;\n      return true;\n    }\n\n    if (ch === 0x0A) {\n      if (!silent) {\n        state.push({\n          type: 'hardbreak',\n          level: state.level\n        });\n      }\n\n      pos++; // skip leading whitespaces from next line\n\n      while (pos < max && state.src.charCodeAt(pos) === 0x20) {\n        pos++;\n      }\n\n      state.pos = pos;\n      return true;\n    }\n  }\n\n  if (!silent) {\n    state.pending += '\\\\';\n  }\n\n  state.pos++;\n  return true;\n} // Parse backticks\n\n\nfunction backticks(state, silent) {\n  var start,\n      max,\n      marker,\n      matchStart,\n      matchEnd,\n      pos = state.pos,\n      ch = state.src.charCodeAt(pos);\n\n  if (ch !== 0x60\n  /* ` */\n  ) {\n      return false;\n    }\n\n  start = pos;\n  pos++;\n  max = state.posMax;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x60\n  /* ` */\n  ) {\n    pos++;\n  }\n\n  marker = state.src.slice(start, pos);\n  matchStart = matchEnd = pos;\n\n  while ((matchStart = state.src.indexOf('`', matchEnd)) !== -1) {\n    matchEnd = matchStart + 1;\n\n    while (matchEnd < max && state.src.charCodeAt(matchEnd) === 0x60\n    /* ` */\n    ) {\n      matchEnd++;\n    }\n\n    if (matchEnd - matchStart === marker.length) {\n      if (!silent) {\n        state.push({\n          type: 'code',\n          content: state.src.slice(pos, matchStart).replace(/[ \\n]+/g, ' ').trim(),\n          block: false,\n          level: state.level\n        });\n      }\n\n      state.pos = matchEnd;\n      return true;\n    }\n  }\n\n  if (!silent) {\n    state.pending += marker;\n  }\n\n  state.pos += marker.length;\n  return true;\n} // Process ~~deleted text~~\n\n\nfunction del(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x7E\n  /* ~ */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  if (start + 4 >= max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start + 1) !== 0x7E\n  /* ~ */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x7E\n  /* ~ */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x7E\n  /* ~ */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x20 || nextChar === 0x0A) {\n    return false;\n  }\n\n  pos = start + 2;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x7E\n  /* ~ */\n  ) {\n    pos++;\n  }\n\n  if (pos > start + 3) {\n    // sequence of 4+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n\n    if (!silent) {\n      state.pending += state.src.slice(start, pos);\n    }\n\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x7E\n    /* ~ */\n    ) {\n        if (state.src.charCodeAt(state.pos + 1) === 0x7E\n        /* ~ */\n        ) {\n            lastChar = state.src.charCodeAt(state.pos - 1);\n            nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n\n            if (nextChar !== 0x7E\n            /* ~ */\n            && lastChar !== 0x7E\n            /* ~ */\n            ) {\n                if (lastChar !== 0x20 && lastChar !== 0x0A) {\n                  // closing '~~'\n                  stack--;\n                } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n                  // opening '~~'\n                  stack++;\n                } // else {\n                //  // standalone ' ~~ ' indented with spaces\n                // }\n\n\n                if (stack <= 0) {\n                  found = true;\n                  break;\n                }\n              }\n          }\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({\n      type: 'del_open',\n      level: state.level++\n    });\n    state.parser.tokenize(state);\n    state.push({\n      type: 'del_close',\n      level: --state.level\n    });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n} // Process ++inserted text++\n\n\nfunction ins(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x2B\n  /* + */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  if (start + 4 >= max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start + 1) !== 0x2B\n  /* + */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x2B\n  /* + */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x2B\n  /* + */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x20 || nextChar === 0x0A) {\n    return false;\n  }\n\n  pos = start + 2;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x2B\n  /* + */\n  ) {\n    pos++;\n  }\n\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n\n    if (!silent) {\n      state.pending += state.src.slice(start, pos);\n    }\n\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x2B\n    /* + */\n    ) {\n        if (state.src.charCodeAt(state.pos + 1) === 0x2B\n        /* + */\n        ) {\n            lastChar = state.src.charCodeAt(state.pos - 1);\n            nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n\n            if (nextChar !== 0x2B\n            /* + */\n            && lastChar !== 0x2B\n            /* + */\n            ) {\n                if (lastChar !== 0x20 && lastChar !== 0x0A) {\n                  // closing '++'\n                  stack--;\n                } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n                  // opening '++'\n                  stack++;\n                } // else {\n                //  // standalone ' ++ ' indented with spaces\n                // }\n\n\n                if (stack <= 0) {\n                  found = true;\n                  break;\n                }\n              }\n          }\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({\n      type: 'ins_open',\n      level: state.level++\n    });\n    state.parser.tokenize(state);\n    state.push({\n      type: 'ins_close',\n      level: --state.level\n    });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n} // Process ==highlighted text==\n\n\nfunction mark(state, silent) {\n  var found,\n      pos,\n      stack,\n      max = state.posMax,\n      start = state.pos,\n      lastChar,\n      nextChar;\n\n  if (state.src.charCodeAt(start) !== 0x3D\n  /* = */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  if (start + 4 >= max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start + 1) !== 0x3D\n  /* = */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n  nextChar = state.src.charCodeAt(start + 2);\n\n  if (lastChar === 0x3D\n  /* = */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x3D\n  /* = */\n  ) {\n      return false;\n    }\n\n  if (nextChar === 0x20 || nextChar === 0x0A) {\n    return false;\n  }\n\n  pos = start + 2;\n\n  while (pos < max && state.src.charCodeAt(pos) === 0x3D\n  /* = */\n  ) {\n    pos++;\n  }\n\n  if (pos !== start + 2) {\n    // sequence of 3+ markers taking as literal, same as in a emphasis\n    state.pos += pos - start;\n\n    if (!silent) {\n      state.pending += state.src.slice(start, pos);\n    }\n\n    return true;\n  }\n\n  state.pos = start + 2;\n  stack = 1;\n\n  while (state.pos + 1 < max) {\n    if (state.src.charCodeAt(state.pos) === 0x3D\n    /* = */\n    ) {\n        if (state.src.charCodeAt(state.pos + 1) === 0x3D\n        /* = */\n        ) {\n            lastChar = state.src.charCodeAt(state.pos - 1);\n            nextChar = state.pos + 2 < max ? state.src.charCodeAt(state.pos + 2) : -1;\n\n            if (nextChar !== 0x3D\n            /* = */\n            && lastChar !== 0x3D\n            /* = */\n            ) {\n                if (lastChar !== 0x20 && lastChar !== 0x0A) {\n                  // closing '=='\n                  stack--;\n                } else if (nextChar !== 0x20 && nextChar !== 0x0A) {\n                  // opening '=='\n                  stack++;\n                } // else {\n                //  // standalone ' == ' indented with spaces\n                // }\n\n\n                if (stack <= 0) {\n                  found = true;\n                  break;\n                }\n              }\n          }\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + 2;\n\n  if (!silent) {\n    state.push({\n      type: 'mark_open',\n      level: state.level++\n    });\n    state.parser.tokenize(state);\n    state.push({\n      type: 'mark_close',\n      level: --state.level\n    });\n  }\n\n  state.pos = state.posMax + 2;\n  state.posMax = max;\n  return true;\n} // Process *this* and _that_\n\n\nfunction isAlphaNum(code) {\n  return code >= 0x30\n  /* 0 */\n  && code <= 0x39\n  /* 9 */\n  || code >= 0x41\n  /* A */\n  && code <= 0x5A\n  /* Z */\n  || code >= 0x61\n  /* a */\n  && code <= 0x7A\n  /* z */\n  ;\n} // parse sequence of emphasis markers,\n// \"start\" should point at a valid marker\n\n\nfunction scanDelims(state, start) {\n  var pos = start,\n      lastChar,\n      nextChar,\n      count,\n      can_open = true,\n      can_close = true,\n      max = state.posMax,\n      marker = state.src.charCodeAt(start);\n  lastChar = start > 0 ? state.src.charCodeAt(start - 1) : -1;\n\n  while (pos < max && state.src.charCodeAt(pos) === marker) {\n    pos++;\n  }\n\n  if (pos >= max) {\n    can_open = false;\n  }\n\n  count = pos - start;\n\n  if (count >= 4) {\n    // sequence of four or more unescaped markers can't start/end an emphasis\n    can_open = can_close = false;\n  } else {\n    nextChar = pos < max ? state.src.charCodeAt(pos) : -1; // check whitespace conditions\n\n    if (nextChar === 0x20 || nextChar === 0x0A) {\n      can_open = false;\n    }\n\n    if (lastChar === 0x20 || lastChar === 0x0A) {\n      can_close = false;\n    }\n\n    if (marker === 0x5F\n    /* _ */\n    ) {\n        // check if we aren't inside the word\n        if (isAlphaNum(lastChar)) {\n          can_open = false;\n        }\n\n        if (isAlphaNum(nextChar)) {\n          can_close = false;\n        }\n      }\n  }\n\n  return {\n    can_open: can_open,\n    can_close: can_close,\n    delims: count\n  };\n}\n\nfunction emphasis(state, silent) {\n  var startCount,\n      count,\n      found,\n      oldCount,\n      newCount,\n      stack,\n      res,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker !== 0x5F\n  /* _ */\n  && marker !== 0x2A\n  /* * */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  res = scanDelims(state, start);\n  startCount = res.delims;\n\n  if (!res.can_open) {\n    state.pos += startCount;\n\n    if (!silent) {\n      state.pending += state.src.slice(start, state.pos);\n    }\n\n    return true;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  state.pos = start + startCount;\n  stack = [startCount];\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === marker) {\n      res = scanDelims(state, state.pos);\n      count = res.delims;\n\n      if (res.can_close) {\n        oldCount = stack.pop();\n        newCount = count;\n\n        while (oldCount !== newCount) {\n          if (newCount < oldCount) {\n            stack.push(oldCount - newCount);\n            break;\n          } // assert(newCount > oldCount)\n\n\n          newCount -= oldCount;\n\n          if (stack.length === 0) {\n            break;\n          }\n\n          state.pos += oldCount;\n          oldCount = stack.pop();\n        }\n\n        if (stack.length === 0) {\n          startCount = oldCount;\n          found = true;\n          break;\n        }\n\n        state.pos += count;\n        continue;\n      }\n\n      if (res.can_open) {\n        stack.push(count);\n      }\n\n      state.pos += count;\n      continue;\n    }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found) {\n    // parser failed to find ending tag, so it's not valid emphasis\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + startCount;\n\n  if (!silent) {\n    if (startCount === 2 || startCount === 3) {\n      state.push({\n        type: 'strong_open',\n        level: state.level++\n      });\n    }\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({\n        type: 'em_open',\n        level: state.level++\n      });\n    }\n\n    state.parser.tokenize(state);\n\n    if (startCount === 1 || startCount === 3) {\n      state.push({\n        type: 'em_close',\n        level: --state.level\n      });\n    }\n\n    if (startCount === 2 || startCount === 3) {\n      state.push({\n        type: 'strong_close',\n        level: --state.level\n      });\n    }\n  }\n\n  state.pos = state.posMax + startCount;\n  state.posMax = max;\n  return true;\n} // Process ~subscript~\n// same as UNESCAPE_MD_RE plus a space\n\n\nvar UNESCAPE_RE = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction sub(state, silent) {\n  var found,\n      content,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(start) !== 0x7E\n  /* ~ */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  if (start + 2 >= max) {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  state.pos = start + 1;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x7E\n    /* ~ */\n    ) {\n        found = true;\n        break;\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n\n  content = state.src.slice(start + 1, state.pos); // don't allow unescaped spaces/newlines inside\n\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + 1;\n\n  if (!silent) {\n    state.push({\n      type: 'sub',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE, '$1')\n    });\n  }\n\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n} // Process ^superscript^\n// same as UNESCAPE_MD_RE plus a space\n\n\nvar UNESCAPE_RE$1 = /\\\\([ \\\\!\"#$%&'()*+,.\\/:;<=>?@[\\]^_`{|}~-])/g;\n\nfunction sup(state, silent) {\n  var found,\n      content,\n      max = state.posMax,\n      start = state.pos;\n\n  if (state.src.charCodeAt(start) !== 0x5E\n  /* ^ */\n  ) {\n      return false;\n    }\n\n  if (silent) {\n    return false;\n  } // don't run any pairs in validation mode\n\n\n  if (start + 2 >= max) {\n    return false;\n  }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  state.pos = start + 1;\n\n  while (state.pos < max) {\n    if (state.src.charCodeAt(state.pos) === 0x5E\n    /* ^ */\n    ) {\n        found = true;\n        break;\n      }\n\n    state.parser.skipToken(state);\n  }\n\n  if (!found || start + 1 === state.pos) {\n    state.pos = start;\n    return false;\n  }\n\n  content = state.src.slice(start + 1, state.pos); // don't allow unescaped spaces/newlines inside\n\n  if (content.match(/(^|[^\\\\])(\\\\\\\\)*\\s/)) {\n    state.pos = start;\n    return false;\n  } // found!\n\n\n  state.posMax = state.pos;\n  state.pos = start + 1;\n\n  if (!silent) {\n    state.push({\n      type: 'sup',\n      level: state.level,\n      content: content.replace(UNESCAPE_RE$1, '$1')\n    });\n  }\n\n  state.pos = state.posMax + 1;\n  state.posMax = max;\n  return true;\n} // Process [links](<to> \"stuff\")\n\n\nfunction links(state, silent) {\n  var labelStart,\n      labelEnd,\n      label,\n      href,\n      title,\n      pos,\n      ref,\n      code,\n      isImage = false,\n      oldPos = state.pos,\n      max = state.posMax,\n      start = state.pos,\n      marker = state.src.charCodeAt(start);\n\n  if (marker === 0x21\n  /* ! */\n  ) {\n      isImage = true;\n      marker = state.src.charCodeAt(++start);\n    }\n\n  if (marker !== 0x5B\n  /* [ */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  labelStart = start + 1;\n  labelEnd = parseLinkLabel(state, start); // parser failed to find ']', so it's not a valid link\n\n  if (labelEnd < 0) {\n    return false;\n  }\n\n  pos = labelEnd + 1;\n\n  if (pos < max && state.src.charCodeAt(pos) === 0x28\n  /* ( */\n  ) {\n      //\n      // Inline link\n      //\n      // [link](  <href>  \"title\"  )\n      //        ^^ skipping these spaces\n      pos++;\n\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n\n        if (code !== 0x20 && code !== 0x0A) {\n          break;\n        }\n      }\n\n      if (pos >= max) {\n        return false;\n      } // [link](  <href>  \"title\"  )\n      //          ^^^^^^ parsing link destination\n\n\n      start = pos;\n\n      if (parseLinkDestination(state, pos)) {\n        href = state.linkContent;\n        pos = state.pos;\n      } else {\n        href = '';\n      } // [link](  <href>  \"title\"  )\n      //                ^^ skipping these spaces\n\n\n      start = pos;\n\n      for (; pos < max; pos++) {\n        code = state.src.charCodeAt(pos);\n\n        if (code !== 0x20 && code !== 0x0A) {\n          break;\n        }\n      } // [link](  <href>  \"title\"  )\n      //                  ^^^^^^^ parsing link title\n\n\n      if (pos < max && start !== pos && parseLinkTitle(state, pos)) {\n        title = state.linkContent;\n        pos = state.pos; // [link](  <href>  \"title\"  )\n        //                         ^^ skipping these spaces\n\n        for (; pos < max; pos++) {\n          code = state.src.charCodeAt(pos);\n\n          if (code !== 0x20 && code !== 0x0A) {\n            break;\n          }\n        }\n      } else {\n        title = '';\n      }\n\n      if (pos >= max || state.src.charCodeAt(pos) !== 0x29\n      /* ) */\n      ) {\n          state.pos = oldPos;\n          return false;\n        }\n\n      pos++;\n    } else {\n    //\n    // Link reference\n    //\n    // do not allow nested reference links\n    if (state.linkLevel > 0) {\n      return false;\n    } // [foo]  [bar]\n    //      ^^ optional whitespace (can include newlines)\n\n\n    for (; pos < max; pos++) {\n      code = state.src.charCodeAt(pos);\n\n      if (code !== 0x20 && code !== 0x0A) {\n        break;\n      }\n    }\n\n    if (pos < max && state.src.charCodeAt(pos) === 0x5B\n    /* [ */\n    ) {\n        start = pos + 1;\n        pos = parseLinkLabel(state, pos);\n\n        if (pos >= 0) {\n          label = state.src.slice(start, pos++);\n        } else {\n          pos = start - 1;\n        }\n      } // covers label === '' and label === undefined\n    // (collapsed reference link and shortcut reference link respectively)\n\n\n    if (!label) {\n      if (typeof label === 'undefined') {\n        pos = labelEnd + 1;\n      }\n\n      label = state.src.slice(labelStart, labelEnd);\n    }\n\n    ref = state.env.references[normalizeReference(label)];\n\n    if (!ref) {\n      state.pos = oldPos;\n      return false;\n    }\n\n    href = ref.href;\n    title = ref.title;\n  } //\n  // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n\n\n  if (!silent) {\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n\n    if (isImage) {\n      state.push({\n        type: 'image',\n        src: href,\n        title: title,\n        alt: state.src.substr(labelStart, labelEnd - labelStart),\n        level: state.level\n      });\n    } else {\n      state.push({\n        type: 'link_open',\n        href: href,\n        title: title,\n        level: state.level++\n      });\n      state.linkLevel++;\n      state.parser.tokenize(state);\n      state.linkLevel--;\n      state.push({\n        type: 'link_close',\n        level: --state.level\n      });\n    }\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n} // Process inline footnotes (^[...])\n\n\nfunction footnote_inline(state, silent) {\n  var labelStart,\n      labelEnd,\n      footnoteId,\n      oldLength,\n      max = state.posMax,\n      start = state.pos;\n\n  if (start + 2 >= max) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start) !== 0x5E\n  /* ^ */\n  ) {\n      return false;\n    }\n\n  if (state.src.charCodeAt(start + 1) !== 0x5B\n  /* [ */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  labelStart = start + 2;\n  labelEnd = parseLinkLabel(state, start + 1); // parser failed to find ']', so it's not a valid note\n\n  if (labelEnd < 0) {\n    return false;\n  } // We found the end of the link, and know for a fact it's a valid link;\n  // so all that's left to do is to call tokenizer.\n  //\n\n\n  if (!silent) {\n    if (!state.env.footnotes) {\n      state.env.footnotes = {};\n    }\n\n    if (!state.env.footnotes.list) {\n      state.env.footnotes.list = [];\n    }\n\n    footnoteId = state.env.footnotes.list.length;\n    state.pos = labelStart;\n    state.posMax = labelEnd;\n    state.push({\n      type: 'footnote_ref',\n      id: footnoteId,\n      level: state.level\n    });\n    state.linkLevel++;\n    oldLength = state.tokens.length;\n    state.parser.tokenize(state);\n    state.env.footnotes.list[footnoteId] = {\n      tokens: state.tokens.splice(oldLength)\n    };\n    state.linkLevel--;\n  }\n\n  state.pos = labelEnd + 1;\n  state.posMax = max;\n  return true;\n} // Process footnote references ([^...])\n\n\nfunction footnote_ref(state, silent) {\n  var label,\n      pos,\n      footnoteId,\n      footnoteSubId,\n      max = state.posMax,\n      start = state.pos; // should be at least 4 chars - \"[^x]\"\n\n  if (start + 3 > max) {\n    return false;\n  }\n\n  if (!state.env.footnotes || !state.env.footnotes.refs) {\n    return false;\n  }\n\n  if (state.src.charCodeAt(start) !== 0x5B\n  /* [ */\n  ) {\n      return false;\n    }\n\n  if (state.src.charCodeAt(start + 1) !== 0x5E\n  /* ^ */\n  ) {\n      return false;\n    }\n\n  if (state.level >= state.options.maxNesting) {\n    return false;\n  }\n\n  for (pos = start + 2; pos < max; pos++) {\n    if (state.src.charCodeAt(pos) === 0x20) {\n      return false;\n    }\n\n    if (state.src.charCodeAt(pos) === 0x0A) {\n      return false;\n    }\n\n    if (state.src.charCodeAt(pos) === 0x5D\n    /* ] */\n    ) {\n        break;\n      }\n  }\n\n  if (pos === start + 2) {\n    return false;\n  } // no empty footnote labels\n\n\n  if (pos >= max) {\n    return false;\n  }\n\n  pos++;\n  label = state.src.slice(start + 2, pos - 1);\n\n  if (typeof state.env.footnotes.refs[':' + label] === 'undefined') {\n    return false;\n  }\n\n  if (!silent) {\n    if (!state.env.footnotes.list) {\n      state.env.footnotes.list = [];\n    }\n\n    if (state.env.footnotes.refs[':' + label] < 0) {\n      footnoteId = state.env.footnotes.list.length;\n      state.env.footnotes.list[footnoteId] = {\n        label: label,\n        count: 0\n      };\n      state.env.footnotes.refs[':' + label] = footnoteId;\n    } else {\n      footnoteId = state.env.footnotes.refs[':' + label];\n    }\n\n    footnoteSubId = state.env.footnotes.list[footnoteId].count;\n    state.env.footnotes.list[footnoteId].count++;\n    state.push({\n      type: 'footnote_ref',\n      id: footnoteId,\n      subId: footnoteSubId,\n      level: state.level\n    });\n  }\n\n  state.pos = pos;\n  state.posMax = max;\n  return true;\n} // List of valid url schemas, accorting to commonmark spec\n// http://jgm.github.io/CommonMark/spec.html#autolinks\n\n\nvar url_schemas = ['coap', 'doi', 'javascript', 'aaa', 'aaas', 'about', 'acap', 'cap', 'cid', 'crid', 'data', 'dav', 'dict', 'dns', 'file', 'ftp', 'geo', 'go', 'gopher', 'h323', 'http', 'https', 'iax', 'icap', 'im', 'imap', 'info', 'ipp', 'iris', 'iris.beep', 'iris.xpc', 'iris.xpcs', 'iris.lwz', 'ldap', 'mailto', 'mid', 'msrp', 'msrps', 'mtqp', 'mupdate', 'news', 'nfs', 'ni', 'nih', 'nntp', 'opaquelocktoken', 'pop', 'pres', 'rtsp', 'service', 'session', 'shttp', 'sieve', 'sip', 'sips', 'sms', 'snmp', 'soap.beep', 'soap.beeps', 'tag', 'tel', 'telnet', 'tftp', 'thismessage', 'tn3270', 'tip', 'tv', 'urn', 'vemmi', 'ws', 'wss', 'xcon', 'xcon-userid', 'xmlrpc.beep', 'xmlrpc.beeps', 'xmpp', 'z39.50r', 'z39.50s', 'adiumxtra', 'afp', 'afs', 'aim', 'apt', 'attachment', 'aw', 'beshare', 'bitcoin', 'bolo', 'callto', 'chrome', 'chrome-extension', 'com-eventbrite-attendee', 'content', 'cvs', 'dlna-playsingle', 'dlna-playcontainer', 'dtn', 'dvb', 'ed2k', 'facetime', 'feed', 'finger', 'fish', 'gg', 'git', 'gizmoproject', 'gtalk', 'hcp', 'icon', 'ipn', 'irc', 'irc6', 'ircs', 'itms', 'jar', 'jms', 'keyparc', 'lastfm', 'ldaps', 'magnet', 'maps', 'market', 'message', 'mms', 'ms-help', 'msnim', 'mumble', 'mvn', 'notes', 'oid', 'palm', 'paparazzi', 'platform', 'proxy', 'psyc', 'query', 'res', 'resource', 'rmi', 'rsync', 'rtmp', 'secondlife', 'sftp', 'sgn', 'skype', 'smb', 'soldat', 'spotify', 'ssh', 'steam', 'svn', 'teamspeak', 'things', 'udp', 'unreal', 'ut2004', 'ventrilo', 'view-source', 'webcal', 'wtai', 'wyciwyg', 'xfire', 'xri', 'ymsgr']; // Process autolinks '<protocol:...>'\n\n/*eslint max-len:0*/\n\nvar EMAIL_RE = /^<([a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*)>/;\nvar AUTOLINK_RE = /^<([a-zA-Z.\\-]{1,25}):([^<>\\x00-\\x20]*)>/;\n\nfunction autolink(state, silent) {\n  var tail,\n      linkMatch,\n      emailMatch,\n      url,\n      fullUrl,\n      pos = state.pos;\n\n  if (state.src.charCodeAt(pos) !== 0x3C\n  /* < */\n  ) {\n      return false;\n    }\n\n  tail = state.src.slice(pos);\n\n  if (tail.indexOf('>') < 0) {\n    return false;\n  }\n\n  linkMatch = tail.match(AUTOLINK_RE);\n\n  if (linkMatch) {\n    if (url_schemas.indexOf(linkMatch[1].toLowerCase()) < 0) {\n      return false;\n    }\n\n    url = linkMatch[0].slice(1, -1);\n    fullUrl = normalizeLink(url);\n\n    if (!state.parser.validateLink(url)) {\n      return false;\n    }\n\n    if (!silent) {\n      state.push({\n        type: 'link_open',\n        href: fullUrl,\n        level: state.level\n      });\n      state.push({\n        type: 'text',\n        content: url,\n        level: state.level + 1\n      });\n      state.push({\n        type: 'link_close',\n        level: state.level\n      });\n    }\n\n    state.pos += linkMatch[0].length;\n    return true;\n  }\n\n  emailMatch = tail.match(EMAIL_RE);\n\n  if (emailMatch) {\n    url = emailMatch[0].slice(1, -1);\n    fullUrl = normalizeLink('mailto:' + url);\n\n    if (!state.parser.validateLink(fullUrl)) {\n      return false;\n    }\n\n    if (!silent) {\n      state.push({\n        type: 'link_open',\n        href: fullUrl,\n        level: state.level\n      });\n      state.push({\n        type: 'text',\n        content: url,\n        level: state.level + 1\n      });\n      state.push({\n        type: 'link_close',\n        level: state.level\n      });\n    }\n\n    state.pos += emailMatch[0].length;\n    return true;\n  }\n\n  return false;\n} // Regexps to match html elements\n\n\nfunction replace$1(regex, options) {\n  regex = regex.source;\n  options = options || '';\n  return function self(name, val) {\n    if (!name) {\n      return new RegExp(regex, options);\n    }\n\n    val = val.source || val;\n    regex = regex.replace(name, val);\n    return self;\n  };\n}\n\nvar attr_name = /[a-zA-Z_:][a-zA-Z0-9:._-]*/;\nvar unquoted = /[^\"'=<>`\\x00-\\x20]+/;\nvar single_quoted = /'[^']*'/;\nvar double_quoted = /\"[^\"]*\"/;\n/*eslint no-spaced-func:0*/\n\nvar attr_value = replace$1(/(?:unquoted|single_quoted|double_quoted)/)('unquoted', unquoted)('single_quoted', single_quoted)('double_quoted', double_quoted)();\nvar attribute = replace$1(/(?:\\s+attr_name(?:\\s*=\\s*attr_value)?)/)('attr_name', attr_name)('attr_value', attr_value)();\nvar open_tag = replace$1(/<[A-Za-z][A-Za-z0-9]*attribute*\\s*\\/?>/)('attribute', attribute)();\nvar close_tag = /<\\/[A-Za-z][A-Za-z0-9]*\\s*>/;\nvar comment = /<!---->|<!--(?:-?[^>-])(?:-?[^-])*-->/;\nvar processing = /<[?].*?[?]>/;\nvar declaration = /<![A-Z]+\\s+[^>]*>/;\nvar cdata = /<!\\[CDATA\\[[\\s\\S]*?\\]\\]>/;\nvar HTML_TAG_RE = replace$1(/^(?:open_tag|close_tag|comment|processing|declaration|cdata)/)('open_tag', open_tag)('close_tag', close_tag)('comment', comment)('processing', processing)('declaration', declaration)('cdata', cdata)(); // Process html tags\n\nfunction isLetter$2(ch) {\n  /*eslint no-bitwise:0*/\n  var lc = ch | 0x20; // to lower case\n\n  return lc >= 0x61\n  /* a */\n  && lc <= 0x7a\n  /* z */\n  ;\n}\n\nfunction htmltag(state, silent) {\n  var ch,\n      match,\n      max,\n      pos = state.pos;\n\n  if (!state.options.html) {\n    return false;\n  } // Check start\n\n\n  max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x3C\n  /* < */\n  || pos + 2 >= max) {\n    return false;\n  } // Quick fail on second char\n\n\n  ch = state.src.charCodeAt(pos + 1);\n\n  if (ch !== 0x21\n  /* ! */\n  && ch !== 0x3F\n  /* ? */\n  && ch !== 0x2F\n  /* / */\n  && !isLetter$2(ch)) {\n    return false;\n  }\n\n  match = state.src.slice(pos).match(HTML_TAG_RE);\n\n  if (!match) {\n    return false;\n  }\n\n  if (!silent) {\n    state.push({\n      type: 'htmltag',\n      content: state.src.slice(pos, pos + match[0].length),\n      level: state.level\n    });\n  }\n\n  state.pos += match[0].length;\n  return true;\n} // Process html entity - &#123;, &#xAF;, &quot;, ...\n\n\nvar DIGITAL_RE = /^&#((?:x[a-f0-9]{1,8}|[0-9]{1,8}));/i;\nvar NAMED_RE = /^&([a-z][a-z0-9]{1,31});/i;\n\nfunction entity(state, silent) {\n  var ch,\n      code,\n      match,\n      pos = state.pos,\n      max = state.posMax;\n\n  if (state.src.charCodeAt(pos) !== 0x26\n  /* & */\n  ) {\n      return false;\n    }\n\n  if (pos + 1 < max) {\n    ch = state.src.charCodeAt(pos + 1);\n\n    if (ch === 0x23\n    /* # */\n    ) {\n        match = state.src.slice(pos).match(DIGITAL_RE);\n\n        if (match) {\n          if (!silent) {\n            code = match[1][0].toLowerCase() === 'x' ? parseInt(match[1].slice(1), 16) : parseInt(match[1], 10);\n            state.pending += isValidEntityCode(code) ? fromCodePoint(code) : fromCodePoint(0xFFFD);\n          }\n\n          state.pos += match[0].length;\n          return true;\n        }\n      } else {\n      match = state.src.slice(pos).match(NAMED_RE);\n\n      if (match) {\n        var decoded = decodeEntity(match[1]);\n\n        if (match[1] !== decoded) {\n          if (!silent) {\n            state.pending += decoded;\n          }\n\n          state.pos += match[0].length;\n          return true;\n        }\n      }\n    }\n  }\n\n  if (!silent) {\n    state.pending += '&';\n  }\n\n  state.pos++;\n  return true;\n}\n/**\n * Inline Parser `rules`\n */\n\n\nvar _rules$2 = [['text', text], ['newline', newline], ['escape', escape], ['backticks', backticks], ['del', del], ['ins', ins], ['mark', mark], ['emphasis', emphasis], ['sub', sub], ['sup', sup], ['links', links], ['footnote_inline', footnote_inline], ['footnote_ref', footnote_ref], ['autolink', autolink], ['htmltag', htmltag], ['entity', entity]];\n/**\n * Inline Parser class. Note that link validation is stricter\n * in Remarkable than what is specified by CommonMark. If you\n * want to change this you can use a custom validator.\n *\n * @api private\n */\n\nfunction ParserInline() {\n  this.ruler = new Ruler();\n\n  for (var i = 0; i < _rules$2.length; i++) {\n    this.ruler.push(_rules$2[i][0], _rules$2[i][1]);\n  } // Can be overridden with a custom validator\n\n\n  this.validateLink = validateLink;\n}\n/**\n * Skip a single token by running all rules in validation mode.\n * Returns `true` if any rule reports success.\n *\n * @param  {Object} `state`\n * @api privage\n */\n\n\nParserInline.prototype.skipToken = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var pos = state.pos;\n  var i, cached_pos;\n\n  if ((cached_pos = state.cacheGet(pos)) > 0) {\n    state.pos = cached_pos;\n    return;\n  }\n\n  for (i = 0; i < len; i++) {\n    if (rules[i](state, true)) {\n      state.cacheSet(pos, state.pos);\n      return;\n    }\n  }\n\n  state.pos++;\n  state.cacheSet(pos, state.pos);\n};\n/**\n * Generate tokens for the given input range.\n *\n * @param  {Object} `state`\n * @api private\n */\n\n\nParserInline.prototype.tokenize = function (state) {\n  var rules = this.ruler.getRules('');\n  var len = rules.length;\n  var end = state.posMax;\n  var ok, i;\n\n  while (state.pos < end) {\n    // Try all possible rules.\n    // On success, the rule should:\n    //\n    // - update `state.pos`\n    // - update `state.tokens`\n    // - return true\n    for (i = 0; i < len; i++) {\n      ok = rules[i](state, false);\n\n      if (ok) {\n        break;\n      }\n    }\n\n    if (ok) {\n      if (state.pos >= end) {\n        break;\n      }\n\n      continue;\n    }\n\n    state.pending += state.src[state.pos++];\n  }\n\n  if (state.pending) {\n    state.pushPending();\n  }\n};\n/**\n * Parse the given input string.\n *\n * @param  {String} `str`\n * @param  {Object} `options`\n * @param  {Object} `env`\n * @param  {Array} `outTokens`\n * @api private\n */\n\n\nParserInline.prototype.parse = function (str, options, env, outTokens) {\n  var state = new StateInline(str, this, options, env, outTokens);\n  this.tokenize(state);\n};\n/**\n * Validate the given `url` by checking for bad protocols.\n *\n * @param  {String} `url`\n * @return {Boolean}\n */\n\n\nfunction validateLink(url) {\n  var BAD_PROTOCOLS = ['vbscript', 'javascript', 'file', 'data'];\n  var str = url.trim().toLowerCase(); // Care about digital entities \"javascript&#x3A;alert(1)\"\n\n  str = replaceEntities(str);\n\n  if (str.indexOf(':') !== -1 && BAD_PROTOCOLS.indexOf(str.split(':')[0]) !== -1) {\n    return false;\n  }\n\n  return true;\n} // Remarkable default options\n\n\nvar defaultConfig = {\n  options: {\n    html: false,\n    // Enable HTML tags in source\n    xhtmlOut: false,\n    // Use '/' to close single tags (<br />)\n    breaks: false,\n    // Convert '\\n' in paragraphs into <br>\n    langPrefix: 'language-',\n    // CSS language prefix for fenced blocks\n    linkTarget: '',\n    // set target to open link in\n    // Enable some language-neutral replacements + quotes beautification\n    typographer: false,\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n    maxNesting: 20 // Internal protection, recursion limit\n\n  },\n  components: {\n    core: {\n      rules: ['block', 'inline', 'references', 'replacements', 'smartquotes', 'references', 'abbr2', 'footnote_tail']\n    },\n    block: {\n      rules: ['blockquote', 'code', 'fences', 'footnote', 'heading', 'hr', 'htmlblock', 'lheading', 'list', 'paragraph', 'table']\n    },\n    inline: {\n      rules: ['autolink', 'backticks', 'del', 'emphasis', 'entity', 'escape', 'footnote_ref', 'htmltag', 'links', 'newline', 'text']\n    }\n  }\n}; // Remarkable default options\n\nvar fullConfig = {\n  options: {\n    html: false,\n    // Enable HTML tags in source\n    xhtmlOut: false,\n    // Use '/' to close single tags (<br />)\n    breaks: false,\n    // Convert '\\n' in paragraphs into <br>\n    langPrefix: 'language-',\n    // CSS language prefix for fenced blocks\n    linkTarget: '',\n    // set target to open link in\n    // Enable some language-neutral replacements + quotes beautification\n    typographer: false,\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n    maxNesting: 20 // Internal protection, recursion limit\n\n  },\n  components: {\n    // Don't restrict core/block/inline rules\n    core: {},\n    block: {},\n    inline: {}\n  }\n}; // Commonmark default options\n\nvar commonmarkConfig = {\n  options: {\n    html: true,\n    // Enable HTML tags in source\n    xhtmlOut: true,\n    // Use '/' to close single tags (<br />)\n    breaks: false,\n    // Convert '\\n' in paragraphs into <br>\n    langPrefix: 'language-',\n    // CSS language prefix for fenced blocks\n    linkTarget: '',\n    // set target to open link in\n    // Enable some language-neutral replacements + quotes beautification\n    typographer: false,\n    // Double + single quotes replacement pairs, when typographer enabled,\n    // and smartquotes on. Set doubles to '«»' for Russian, '„“' for German.\n    quotes: '“”‘’',\n    // Highlighter function. Should return escaped HTML,\n    // or '' if input not changed\n    //\n    // function (/*str, lang*/) { return ''; }\n    //\n    highlight: null,\n    maxNesting: 20 // Internal protection, recursion limit\n\n  },\n  components: {\n    core: {\n      rules: ['block', 'inline', 'references', 'abbr2']\n    },\n    block: {\n      rules: ['blockquote', 'code', 'fences', 'heading', 'hr', 'htmlblock', 'lheading', 'list', 'paragraph']\n    },\n    inline: {\n      rules: ['autolink', 'backticks', 'emphasis', 'entity', 'escape', 'htmltag', 'links', 'newline', 'text']\n    }\n  }\n};\n/**\n * Preset configs\n */\n\nvar config = {\n  'default': defaultConfig,\n  'full': fullConfig,\n  'commonmark': commonmarkConfig\n};\n/**\n * The `StateCore` class manages state.\n *\n * @param {Object} `instance` Remarkable instance\n * @param {String} `str` Markdown string\n * @param {Object} `env`\n */\n\nfunction StateCore(instance, str, env) {\n  this.src = str;\n  this.env = env;\n  this.options = instance.options;\n  this.tokens = [];\n  this.inlineMode = false;\n  this.inline = instance.inline;\n  this.block = instance.block;\n  this.renderer = instance.renderer;\n  this.typographer = instance.typographer;\n}\n/**\n * The main `Remarkable` class. Create an instance of\n * `Remarkable` with a `preset` and/or `options`.\n *\n * @param {String} `preset` If no preset is given, `default` is used.\n * @param {Object} `options`\n */\n\n\nfunction Remarkable(preset, options) {\n  if (typeof preset !== 'string') {\n    options = preset;\n    preset = 'default';\n  }\n\n  if (options && options.linkify != null) {\n    console.warn('linkify option is removed. Use linkify plugin instead:\\n\\n' + 'import Remarkable from \\'remarkable\\';\\n' + 'import linkify from \\'remarkable/linkify\\';\\n' + 'new Remarkable().use(linkify)\\n');\n  }\n\n  this.inline = new ParserInline();\n  this.block = new ParserBlock();\n  this.core = new Core();\n  this.renderer = new Renderer();\n  this.ruler = new Ruler();\n  this.options = {};\n  this.configure(config[preset]);\n  this.set(options || {});\n}\n/**\n * Set options as an alternative to passing them\n * to the constructor.\n *\n * ```js\n * md.set({typographer: true});\n * ```\n * @param {Object} `options`\n * @api public\n */\n\n\nRemarkable.prototype.set = function (options) {\n  assign(this.options, options);\n};\n/**\n * Batch loader for components rules states, and options\n *\n * @param  {Object} `presets`\n */\n\n\nRemarkable.prototype.configure = function (presets) {\n  var self = this;\n\n  if (!presets) {\n    throw new Error('Wrong `remarkable` preset, check name/content');\n  }\n\n  if (presets.options) {\n    self.set(presets.options);\n  }\n\n  if (presets.components) {\n    Object.keys(presets.components).forEach(function (name) {\n      if (presets.components[name].rules) {\n        self[name].ruler.enable(presets.components[name].rules, true);\n      }\n    });\n  }\n};\n/**\n * Use a plugin.\n *\n * ```js\n * var md = new Remarkable();\n *\n * md.use(plugin1)\n *   .use(plugin2, opts)\n *   .use(plugin3);\n * ```\n *\n * @param  {Function} `plugin`\n * @param  {Object} `options`\n * @return {Object} `Remarkable` for chaining\n */\n\n\nRemarkable.prototype.use = function (plugin, options) {\n  plugin(this, options);\n  return this;\n};\n/**\n * Parse the input `string` and return a tokens array.\n * Modifies `env` with definitions data.\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {Array} Array of tokens\n */\n\n\nRemarkable.prototype.parse = function (str, env) {\n  var state = new StateCore(this, str, env);\n  this.core.process(state);\n  return state.tokens;\n};\n/**\n * The main `.render()` method that does all the magic :)\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {String} Rendered HTML.\n */\n\n\nRemarkable.prototype.render = function (str, env) {\n  env = env || {};\n  return this.renderer.render(this.parse(str, env), this.options, env);\n};\n/**\n * Parse the given content `string` as a single string.\n *\n * @param  {String} `string`\n * @param  {Object} `env`\n * @return {Array} Array of tokens\n */\n\n\nRemarkable.prototype.parseInline = function (str, env) {\n  var state = new StateCore(this, str, env);\n  state.inlineMode = true;\n  this.core.process(state);\n  return state.tokens;\n};\n/**\n * Render a single content `string`, without wrapping it\n * to paragraphs\n *\n * @param  {String} `str`\n * @param  {Object} `env`\n * @return {String}\n */\n\n\nRemarkable.prototype.renderInline = function (str, env) {\n  env = env || {};\n  return this.renderer.render(this.parseInline(str, env), this.options, env);\n};\n\nexport { Remarkable, utils };","import React from \"react\"  \nimport { graphql } from \"gatsby\"\nimport { Remarkable } from 'remarkable';\n\nimport Layout from \"./layout\"\nimport SEO from \"../components/seo\"\n\nimport \"../css/album.css\"\n\nexport const query = graphql`\n\tquery AlbumQuery($id: Int!) {\n\t\tstrapiAlbum(strapiId: { eq: $id }) {\n\t\t\tstrapiId\n\t\t\tname\n\t\t\tauthor\n\t\t\tlabel\n\t\t\trelease_year\n\t\t\tbackground_color\n\t\t\tplayer\n\t\t\tdescription\n\t\t\tcover {\n\t\t\t\tpublicURL\n\t\t\t}\n\t\t}\n\t}\n`\n\nconst Album = ({ data }) => {  \n\tconst album = data.strapiAlbum\n\tvar md = new Remarkable()\n\t\n\treturn (\n\t\t<Layout>\n\t\t\t<SEO title={[album.name, album.author].join(' | ')}/>\n\t\t\t<div className=\"hero\" style={{ backgroundColor: album.background_color}}>\n\t\t\t\t<div className=\"hero-content\">\n\t\t\t\t\t<div className=\"band-details\">\n\t\t\t\t\t\t<span className=\"band-detials-section\">\n\t\t\t\t\t\t\t<span className=\"band-name\">{album.author}</span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span className=\"band-detials-section\">\n\t\t\t\t\t\t\t<span className=\"album-name\">{album.name}</span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t\t<span className=\"band-detials-section\">\n\t\t\t\t\t\t\t<span className=\"album-label\">{album.label} - {album.release_year}</span>\n\t\t\t\t\t\t</span>\n\t\t\t\t\t</div>\n\t\t\t\t\t{/* heigth and with are 475px due to hero max-width of hero */}\n\t\t\t\t\t<img className=\"hero-cover\" src={album.cover.publicURL} alt=\"album cover\" height=\"475px\" width=\"475px\"/>\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t\t<section className=\"article\">\n\t\t\t\t<section className=\"player\" dangerouslySetInnerHTML={{__html: album.player}} />\n\t\t\t\t<section className=\"description\" dangerouslySetInnerHTML={{__html: md.render(album.description)}} />\n\t\t\t</section>\n\t\t</Layout>\n\t)\n}\n\nexport default Album","'use strict';\nvar global = require('./_global');\nvar has = require('./_has');\nvar cof = require('./_cof');\nvar inheritIfRequired = require('./_inherit-if-required');\nvar toPrimitive = require('./_to-primitive');\nvar fails = require('./_fails');\nvar gOPN = require('./_object-gopn').f;\nvar gOPD = require('./_object-gopd').f;\nvar dP = require('./_object-dp').f;\nvar $trim = require('./_string-trim').trim;\nvar NUMBER = 'Number';\nvar $Number = global[NUMBER];\nvar Base = $Number;\nvar proto = $Number.prototype;\n// Opera ~12 has broken Object#toString\nvar BROKEN_COF = cof(require('./_object-create')(proto)) == NUMBER;\nvar TRIM = 'trim' in String.prototype;\n\n// 7.1.3 ToNumber(argument)\nvar toNumber = function (argument) {\n  var it = toPrimitive(argument, false);\n  if (typeof it == 'string' && it.length > 2) {\n    it = TRIM ? it.trim() : $trim(it, 3);\n    var first = it.charCodeAt(0);\n    var third, radix, maxCode;\n    if (first === 43 || first === 45) {\n      third = it.charCodeAt(2);\n      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix\n    } else if (first === 48) {\n      switch (it.charCodeAt(1)) {\n        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal /^0b[01]+$/i\n        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal /^0o[0-7]+$/i\n        default: return +it;\n      }\n      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {\n        code = digits.charCodeAt(i);\n        // parseInt parses a string to a first unavailable symbol\n        // but ToNumber should return NaN if a string contains unavailable symbols\n        if (code < 48 || code > maxCode) return NaN;\n      } return parseInt(digits, radix);\n    }\n  } return +it;\n};\n\nif (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {\n  $Number = function Number(value) {\n    var it = arguments.length < 1 ? 0 : value;\n    var that = this;\n    return that instanceof $Number\n      // check on 1..constructor(foo) case\n      && (BROKEN_COF ? fails(function () { proto.valueOf.call(that); }) : cof(that) != NUMBER)\n        ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);\n  };\n  for (var keys = require('./_descriptors') ? gOPN(Base) : (\n    // ES3:\n    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +\n    // ES6 (in case, if modules with ES6 Number statics required before):\n    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +\n    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'\n  ).split(','), j = 0, key; keys.length > j; j++) {\n    if (has(Base, key = keys[j]) && !has($Number, key)) {\n      dP($Number, key, gOPD(Base, key));\n    }\n  }\n  $Number.prototype = proto;\n  proto.constructor = $Number;\n  require('./_redefine')(global, NUMBER, $Number);\n}\n"],"sourceRoot":""}